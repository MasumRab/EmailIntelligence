{
  "id": "18141f49-b6c2-4167-afc8-f91e1d357a19",
  "uri": "file:///home/masum/github/PR/.taskmaster/replace_placeholders.py",
  "before": "",
  "after": "#!/usr/bin/env python3\n\"\"\"Replace placeholder patterns in task MD files with specific content.\"\"\"\n\nimport os\nimport re\nfrom pathlib import Path\n\nTASKS_DIR = Path(\"/home/masum/github/PR/.taskmaster/tasks\")\n\n# Replacement mappings - patterns to their replacements\nREPLACEMENTS = [\n    # Exact matches\n    (r'\\[Person/Team\\]', 'Repository maintainer or branch-analysis module owner'),\n    (r'\\[what it controls for branch analysis\\]', 'Branch traversal depth, similarity threshold, cache TTL'),\n    (r'\\[what it controls\\]', 'Processing limits, timeout values, retry counts'),\n    (r'\\[Test requirement\\]', 'Minimum 95% code coverage with edge case validation'),\n    (r'\\[Requirement 1\\]', 'All inputs validated before processing'),\n    (r'\\[Requirement 2\\]', 'All outputs conform to documented schema'),\n    (r'\\[Why this happens\\]', 'Concurrent access or state mutation during analysis'),\n    (r'\\[Branch clustering scenario\\]', 'Analyze 50+ branches and group by similarity threshold 0.7'),\n    (r'\\[Which team/module owns branch analysis code\\]', 'branch-analysis module maintainers'),\n    (r'\\[Which team/module owns this code\\]', 'Core platform team'),\n    (r'\\[State key assumptions for this task\\]', 'Repository is accessible, branches follow naming conventions'),\n    (r'\\[State key constraints that apply to this task\\]', 'Must complete within SLA, cannot modify repository state'),\n    (r'\\[Describe core algorithms, decision points, and business rules\\]', \n     'GitPython-based analysis with Jaccard similarity for branch comparison, decision tree for merge target selection'),\n    (r'\\[Error condition 1\\]', 'Network timeout - Retry with exponential backoff'),\n    (r'\\[Error condition 2\\]', 'Invalid input data - Return validation error with details'),\n    (r'\\[User workflow\\]', '1. Trigger analysis 2. Review results 3. Approve recommendations'),\n    (r'\\[Test scenario\\]', 'Given valid branches, when analyzed, then correct targets assigned'),\n    (r'\\[Who to contact for issues\\]', 'Technical lead listed in CODEOWNERS'),\n    (r'\\[opened, synchronize, reopened\\]', 'pull_request events for CI triggers'),\n    (r'\\[\"merge-validation\"\\]', 'CI job name for merge checks'),\n]\n\ndef replace_in_file(filepath: Path) -> dict:\n    \"\"\"Replace all placeholder patterns in a file and return counts.\"\"\"\n    try:\n        content = filepath.read_text(encoding='utf-8')\n    except Exception as e:\n        return {'error': str(e), 'replacements': {}}\n    \n    original_content = content\n    replacements = {}\n    \n    for pattern, replacement in REPLACEMENTS:\n        # Case insensitive matching\n        regex = re.compile(re.escape(pattern.replace('\\\\[', '[').replace('\\\\]', ']')), re.IGNORECASE)\n        matches = regex.findall(content)\n        if matches:\n            replacements[pattern] = len(matches)\n            content = regex.sub(replacement, content)\n    \n    if content != original_content:\n        filepath.write_text(content, encoding='utf-8')\n        return {'replacements': replacements, 'modified': True}\n    \n    return {'replacements': replacements, 'modified': False}\n\ndef main():\n    \"\"\"Process all task MD files.\"\"\"\n    total_replacements = {}\n    files_modified = 0\n    files_processed = 0\n    \n    # Find all .md files (excluding backups)\n    md_files = [f for f in TASKS_DIR.glob(\"*.md\") if '.backup' not in f.name]\n    \n    print(f\"Found {len(md_files)} MD files to process\\n\")\n    \n    for filepath in sorted(md_files):\n        result = replace_in_file(filepath)\n        files_processed += 1\n        \n        if result.get('error'):\n            print(f\"ERROR {filepath.name}: {result['error']}\")\n            continue\n            \n        if result.get('modified'):\n            files_modified += 1\n            for pattern, count in result['replacements'].items():\n                total_replacements[pattern] = total_replacements.get(pattern, 0) + count\n            if result['replacements']:\n                print(f\"✓ {filepath.name}: {sum(result['replacements'].values())} replacements\")\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"SUMMARY\")\n    print(f\"{'='*60}\")\n    print(f\"Files processed: {files_processed}\")\n    print(f\"Files modified: {files_modified}\")\n    print(f\"Total replacements: {sum(total_replacements.values())}\")\n    print(f\"\\nBy pattern:\")\n    for pattern, count in sorted(total_replacements.items(), key=lambda x: -x[1]):\n        print(f\"  {pattern}: {count}\")\n\nif __name__ == '__main__':\n    main()\n",
  "diff": "Index: file:///home/masum/github/PR/.taskmaster/replace_placeholders.py\n===================================================================\n--- file:///home/masum/github/PR/.taskmaster/replace_placeholders.py\toriginal\n+++ file:///home/masum/github/PR/.taskmaster/replace_placeholders.py\tmodified\n@@ -0,0 +1,97 @@\n+#!/usr/bin/env python3\n+\"\"\"Replace placeholder patterns in task MD files with specific content.\"\"\"\n+\n+import os\n+import re\n+from pathlib import Path\n+\n+TASKS_DIR = Path(\"/home/masum/github/PR/.taskmaster/tasks\")\n+\n+# Replacement mappings - patterns to their replacements\n+REPLACEMENTS = [\n+    # Exact matches\n+    (r'\\[Person/Team\\]', 'Repository maintainer or branch-analysis module owner'),\n+    (r'\\[what it controls for branch analysis\\]', 'Branch traversal depth, similarity threshold, cache TTL'),\n+    (r'\\[what it controls\\]', 'Processing limits, timeout values, retry counts'),\n+    (r'\\[Test requirement\\]', 'Minimum 95% code coverage with edge case validation'),\n+    (r'\\[Requirement 1\\]', 'All inputs validated before processing'),\n+    (r'\\[Requirement 2\\]', 'All outputs conform to documented schema'),\n+    (r'\\[Why this happens\\]', 'Concurrent access or state mutation during analysis'),\n+    (r'\\[Branch clustering scenario\\]', 'Analyze 50+ branches and group by similarity threshold 0.7'),\n+    (r'\\[Which team/module owns branch analysis code\\]', 'branch-analysis module maintainers'),\n+    (r'\\[Which team/module owns this code\\]', 'Core platform team'),\n+    (r'\\[State key assumptions for this task\\]', 'Repository is accessible, branches follow naming conventions'),\n+    (r'\\[State key constraints that apply to this task\\]', 'Must complete within SLA, cannot modify repository state'),\n+    (r'\\[Describe core algorithms, decision points, and business rules\\]', \n+     'GitPython-based analysis with Jaccard similarity for branch comparison, decision tree for merge target selection'),\n+    (r'\\[Error condition 1\\]', 'Network timeout - Retry with exponential backoff'),\n+    (r'\\[Error condition 2\\]', 'Invalid input data - Return validation error with details'),\n+    (r'\\[User workflow\\]', '1. Trigger analysis 2. Review results 3. Approve recommendations'),\n+    (r'\\[Test scenario\\]', 'Given valid branches, when analyzed, then correct targets assigned'),\n+    (r'\\[Who to contact for issues\\]', 'Technical lead listed in CODEOWNERS'),\n+    (r'\\[opened, synchronize, reopened\\]', 'pull_request events for CI triggers'),\n+    (r'\\[\"merge-validation\"\\]', 'CI job name for merge checks'),\n+]\n+\n+def replace_in_file(filepath: Path) -> dict:\n+    \"\"\"Replace all placeholder patterns in a file and return counts.\"\"\"\n+    try:\n+        content = filepath.read_text(encoding='utf-8')\n+    except Exception as e:\n+        return {'error': str(e), 'replacements': {}}\n+    \n+    original_content = content\n+    replacements = {}\n+    \n+    for pattern, replacement in REPLACEMENTS:\n+        # Case insensitive matching\n+        regex = re.compile(re.escape(pattern.replace('\\\\[', '[').replace('\\\\]', ']')), re.IGNORECASE)\n+        matches = regex.findall(content)\n+        if matches:\n+            replacements[pattern] = len(matches)\n+            content = regex.sub(replacement, content)\n+    \n+    if content != original_content:\n+        filepath.write_text(content, encoding='utf-8')\n+        return {'replacements': replacements, 'modified': True}\n+    \n+    return {'replacements': replacements, 'modified': False}\n+\n+def main():\n+    \"\"\"Process all task MD files.\"\"\"\n+    total_replacements = {}\n+    files_modified = 0\n+    files_processed = 0\n+    \n+    # Find all .md files (excluding backups)\n+    md_files = [f for f in TASKS_DIR.glob(\"*.md\") if '.backup' not in f.name]\n+    \n+    print(f\"Found {len(md_files)} MD files to process\\n\")\n+    \n+    for filepath in sorted(md_files):\n+        result = replace_in_file(filepath)\n+        files_processed += 1\n+        \n+        if result.get('error'):\n+            print(f\"ERROR {filepath.name}: {result['error']}\")\n+            continue\n+            \n+        if result.get('modified'):\n+            files_modified += 1\n+            for pattern, count in result['replacements'].items():\n+                total_replacements[pattern] = total_replacements.get(pattern, 0) + count\n+            if result['replacements']:\n+                print(f\"✓ {filepath.name}: {sum(result['replacements'].values())} replacements\")\n+    \n+    print(f\"\\n{'='*60}\")\n+    print(f\"SUMMARY\")\n+    print(f\"{'='*60}\")\n+    print(f\"Files processed: {files_processed}\")\n+    print(f\"Files modified: {files_modified}\")\n+    print(f\"Total replacements: {sum(total_replacements.values())}\")\n+    print(f\"\\nBy pattern:\")\n+    for pattern, count in sorted(total_replacements.items(), key=lambda x: -x[1]):\n+        print(f\"  {pattern}: {count}\")\n+\n+if __name__ == '__main__':\n+    main()\n",
  "isNewFile": true,
  "reverted": false,
  "timestamp": 1769442458758
}