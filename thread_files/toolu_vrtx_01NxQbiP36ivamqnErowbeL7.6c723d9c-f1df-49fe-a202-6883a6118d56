{
  "id": "6c723d9c-f1df-49fe-a202-6883a6118d56",
  "uri": "file:///home/masum/github/PR/.taskmaster/scripts/taskmaster_runner.py",
  "before": "",
  "after": "#!/usr/bin/env python3\n\"\"\"\nTask Master Runner Utility\n\nProvides a unified interface for running task-master parse-prd with fallback to simulation.\n\"\"\"\n\nimport json\nimport os\nimport re\nimport shutil\nimport subprocess\nimport tempfile\nfrom pathlib import Path\nfrom typing import Callable, List, Optional\n\n\ndef run_task_master_parse_prd(\n    prd_file: str,\n    output_dir: str = None,\n    fallback_simulation: bool = True,\n    extract_task_info_func: Callable = None,\n    original_task_files: List[str] = None,\n    simulation_description: str = \"simulation\",\n    project_root: str = None,\n) -> str:\n    \"\"\"\n    Run task-master parse-prd to generate tasks from PRD.\n    Falls back to simulation if task-master is not available.\n\n    Args:\n        prd_file: Path to the PRD file\n        output_dir: Optional output directory for tasks.json\n        fallback_simulation: Whether to fall back to simulation if task-master is unavailable\n        extract_task_info_func: Function to extract task info from markdown (for simulation)\n        original_task_files: List of original task files (for simulation)\n        simulation_description: Description for simulation mode output\n        project_root: Project root directory for task-master\n\n    Returns:\n        Path to the generated tasks.json file\n    \"\"\"\n    task_master_available = shutil.which(\"task-master\") is not None\n\n    if task_master_available:\n        try:\n            cmd = [\"task-master\", \"parse-prd\", prd_file]\n            if output_dir:\n                cmd.extend([\"--output\", output_dir])\n            if project_root:\n                cmd.extend([\"--project-root\", project_root])\n\n            print(f\"ðŸš€ Running: {' '.join(cmd)}\")\n            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n\n            if result.returncode == 0:\n                print(\"âœ… task-master parse-prd completed successfully\")\n                output_path = output_dir or \".taskmaster/tasks/tasks.json\"\n                if os.path.exists(output_path):\n                    return output_path\n                default_path = \".taskmaster/tasks/tasks.json\"\n                if os.path.exists(default_path):\n                    return default_path\n                print(f\"âš ï¸ Output file not found at expected paths, using default\")\n                return default_path\n            else:\n                print(f\"âš ï¸ task-master parse-prd failed: {result.stderr}\")\n                if fallback_simulation:\n                    print(\"Falling back to simulation mode...\")\n                    return _simulate_parse_prd(\n                        prd_file,\n                        output_dir,\n                        extract_task_info_func,\n                        original_task_files,\n                        simulation_description,\n                    )\n                raise RuntimeError(f\"task-master parse-prd failed: {result.stderr}\")\n        except subprocess.TimeoutExpired:\n            print(\"âš ï¸ task-master parse-prd timed out (300s limit)\")\n            if fallback_simulation:\n                print(\"Falling back to simulation mode...\")\n                return _simulate_parse_prd(\n                    prd_file,\n                    output_dir,\n                    extract_task_info_func,\n                    original_task_files,\n                    simulation_description,\n                )\n            raise\n        except Exception as e:\n            print(f\"âš ï¸ Error running task-master: {e}\")\n            if fallback_simulation:\n                print(\"Falling back to simulation mode...\")\n                return _simulate_parse_prd(\n                    prd_file,\n                    output_dir,\n                    extract_task_info_func,\n                    original_task_files,\n                    simulation_description,\n                )\n            raise\n    elif fallback_simulation:\n        print(\"âš ï¸ task-master not found in PATH, using simulation mode\")\n        return _simulate_parse_prd(\n            prd_file,\n            output_dir,\n            extract_task_info_func,\n            original_task_files,\n            simulation_description,\n        )\n    else:\n        raise RuntimeError(\"task-master not found and fallback_simulation is disabled\")\n\n\ndef _simulate_parse_prd(\n    prd_file: str,\n    output_dir: str = None,\n    extract_task_info_func: Callable = None,\n    original_task_files: List[str] = None,\n    simulation_description: str = \"simulation\",\n) -> str:\n    \"\"\"\n    Fallback simulation when task-master is not available.\n    This should only be used for testing when task-master cannot be installed.\n\n    Args:\n        prd_file: Path to the PRD file (used for context)\n        output_dir: Optional output directory\n        extract_task_info_func: Function to extract task info from markdown\n        original_task_files: List of original task files\n        simulation_description: Description for the output\n\n    Returns:\n        Path to the simulated tasks.json file\n    \"\"\"\n    print(f\"ðŸ“‹ Simulating task-master parse-prd ({simulation_description})\")\n\n    if extract_task_info_func is None or original_task_files is None:\n        raise ValueError(\n            \"extract_task_info_func and original_task_files are required for simulation\"\n        )\n\n    tasks_json = {\n        \"master\": {\n            \"name\": \"Task Master\",\n            \"version\": \"1.0.0\",\n            \"description\": f\"Tasks generated from PRD ({simulation_description})\",\n            \"lastUpdated\": \"2026-01-27T00:00:00Z\",\n            \"tasks\": [],\n        }\n    }\n\n    for task_file in original_task_files:\n        original_info = extract_task_info_func(task_file)\n\n        simulated_task = {\n            \"id\": original_info[\"id\"],\n            \"title\": original_info[\"title\"],\n            \"description\": original_info.get(\"purpose\", \"\"),\n            \"status\": original_info.get(\"status\", \"pending\"),\n            \"priority\": original_info.get(\"priority\", \"medium\"),\n            \"dependencies\": [],\n            \"details\": original_info.get(\"details\", \"\"),\n            \"subtasks\": [],\n            \"testStrategy\": original_info.get(\"test_strategy\", \"\"),\n            \"complexity\": original_info.get(\"complexity\", \"\"),\n            \"effort\": original_info.get(\"effort\", \"\"),\n            \"updatedAt\": \"2026-01-27T00:00:00Z\",\n            \"createdAt\": \"2026-01-27T00:00:00Z\",\n        }\n\n        # Parse dependencies\n        deps = original_info.get(\"dependencies\", \"\")\n        if deps and str(deps).lower() not in [\"none\", \"null\", \"\"]:\n            deps_list = re.split(r\"[,\\s]+| and \", str(deps))\n            deps_list = [d.strip() for d in deps_list if d.strip()]\n            simulated_task[\"dependencies\"] = deps_list\n\n        # Add extended fields if available\n        for field in [\n            \"blocks\",\n            \"initiative\",\n            \"scope\",\n            \"focus\",\n            \"owner\",\n            \"prerequisites\",\n            \"specification_details\",\n            \"implementation_guide\",\n            \"configuration_params\",\n            \"performance_targets\",\n            \"common_gotchas\",\n            \"integration_checkpoint\",\n            \"done_definition\",\n            \"next_steps\",\n            \"extended_metadata\",\n        ]:\n            if original_info.get(field):\n                simulated_task[field] = original_info[field]\n\n        # Add success criteria\n        if original_info.get(\"success_criteria\"):\n            simulated_task[\"success_criteria\"] = original_info[\"success_criteria\"]\n\n        # Add subtasks\n        for subtask in original_info.get(\"subtasks\", []):\n            simulated_subtask = {\n                \"id\": subtask.get(\"id\", 1),\n                \"title\": subtask.get(\"title\", \"\"),\n                \"description\": \"\",\n                \"dependencies\": [],\n                \"details\": \"\",\n                \"testStrategy\": \"\",\n                \"status\": subtask.get(\"status\", \"pending\"),\n                \"parentId\": original_info[\"id\"],\n                \"effort\": \"\",\n            }\n            simulated_task[\"subtasks\"].append(simulated_subtask)\n\n        tasks_json[\"master\"][\"tasks\"].append(simulated_task)\n\n    # Determine output path\n    if output_dir:\n        output_path = Path(output_dir) / \"tasks.json\"\n    else:\n        output_path = Path(\"simulated_tasks.json\")\n\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    with open(output_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(tasks_json, f, indent=2)\n\n    print(f\"ðŸ“ Simulated tasks written to: {output_path}\")\n    return str(output_path)\n\n\ndef check_task_master_available() -> bool:\n    \"\"\"Check if task-master is available in PATH.\"\"\"\n    return shutil.which(\"task-master\") is not None\n",
  "diff": "Index: file:///home/masum/github/PR/.taskmaster/scripts/taskmaster_runner.py\n===================================================================\n--- file:///home/masum/github/PR/.taskmaster/scripts/taskmaster_runner.py\toriginal\n+++ file:///home/masum/github/PR/.taskmaster/scripts/taskmaster_runner.py\tmodified\n@@ -0,0 +1,237 @@\n+#!/usr/bin/env python3\n+\"\"\"\n+Task Master Runner Utility\n+\n+Provides a unified interface for running task-master parse-prd with fallback to simulation.\n+\"\"\"\n+\n+import json\n+import os\n+import re\n+import shutil\n+import subprocess\n+import tempfile\n+from pathlib import Path\n+from typing import Callable, List, Optional\n+\n+\n+def run_task_master_parse_prd(\n+    prd_file: str,\n+    output_dir: str = None,\n+    fallback_simulation: bool = True,\n+    extract_task_info_func: Callable = None,\n+    original_task_files: List[str] = None,\n+    simulation_description: str = \"simulation\",\n+    project_root: str = None,\n+) -> str:\n+    \"\"\"\n+    Run task-master parse-prd to generate tasks from PRD.\n+    Falls back to simulation if task-master is not available.\n+\n+    Args:\n+        prd_file: Path to the PRD file\n+        output_dir: Optional output directory for tasks.json\n+        fallback_simulation: Whether to fall back to simulation if task-master is unavailable\n+        extract_task_info_func: Function to extract task info from markdown (for simulation)\n+        original_task_files: List of original task files (for simulation)\n+        simulation_description: Description for simulation mode output\n+        project_root: Project root directory for task-master\n+\n+    Returns:\n+        Path to the generated tasks.json file\n+    \"\"\"\n+    task_master_available = shutil.which(\"task-master\") is not None\n+\n+    if task_master_available:\n+        try:\n+            cmd = [\"task-master\", \"parse-prd\", prd_file]\n+            if output_dir:\n+                cmd.extend([\"--output\", output_dir])\n+            if project_root:\n+                cmd.extend([\"--project-root\", project_root])\n+\n+            print(f\"ðŸš€ Running: {' '.join(cmd)}\")\n+            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n+\n+            if result.returncode == 0:\n+                print(\"âœ… task-master parse-prd completed successfully\")\n+                output_path = output_dir or \".taskmaster/tasks/tasks.json\"\n+                if os.path.exists(output_path):\n+                    return output_path\n+                default_path = \".taskmaster/tasks/tasks.json\"\n+                if os.path.exists(default_path):\n+                    return default_path\n+                print(f\"âš ï¸ Output file not found at expected paths, using default\")\n+                return default_path\n+            else:\n+                print(f\"âš ï¸ task-master parse-prd failed: {result.stderr}\")\n+                if fallback_simulation:\n+                    print(\"Falling back to simulation mode...\")\n+                    return _simulate_parse_prd(\n+                        prd_file,\n+                        output_dir,\n+                        extract_task_info_func,\n+                        original_task_files,\n+                        simulation_description,\n+                    )\n+                raise RuntimeError(f\"task-master parse-prd failed: {result.stderr}\")\n+        except subprocess.TimeoutExpired:\n+            print(\"âš ï¸ task-master parse-prd timed out (300s limit)\")\n+            if fallback_simulation:\n+                print(\"Falling back to simulation mode...\")\n+                return _simulate_parse_prd(\n+                    prd_file,\n+                    output_dir,\n+                    extract_task_info_func,\n+                    original_task_files,\n+                    simulation_description,\n+                )\n+            raise\n+        except Exception as e:\n+            print(f\"âš ï¸ Error running task-master: {e}\")\n+            if fallback_simulation:\n+                print(\"Falling back to simulation mode...\")\n+                return _simulate_parse_prd(\n+                    prd_file,\n+                    output_dir,\n+                    extract_task_info_func,\n+                    original_task_files,\n+                    simulation_description,\n+                )\n+            raise\n+    elif fallback_simulation:\n+        print(\"âš ï¸ task-master not found in PATH, using simulation mode\")\n+        return _simulate_parse_prd(\n+            prd_file,\n+            output_dir,\n+            extract_task_info_func,\n+            original_task_files,\n+            simulation_description,\n+        )\n+    else:\n+        raise RuntimeError(\"task-master not found and fallback_simulation is disabled\")\n+\n+\n+def _simulate_parse_prd(\n+    prd_file: str,\n+    output_dir: str = None,\n+    extract_task_info_func: Callable = None,\n+    original_task_files: List[str] = None,\n+    simulation_description: str = \"simulation\",\n+) -> str:\n+    \"\"\"\n+    Fallback simulation when task-master is not available.\n+    This should only be used for testing when task-master cannot be installed.\n+\n+    Args:\n+        prd_file: Path to the PRD file (used for context)\n+        output_dir: Optional output directory\n+        extract_task_info_func: Function to extract task info from markdown\n+        original_task_files: List of original task files\n+        simulation_description: Description for the output\n+\n+    Returns:\n+        Path to the simulated tasks.json file\n+    \"\"\"\n+    print(f\"ðŸ“‹ Simulating task-master parse-prd ({simulation_description})\")\n+\n+    if extract_task_info_func is None or original_task_files is None:\n+        raise ValueError(\n+            \"extract_task_info_func and original_task_files are required for simulation\"\n+        )\n+\n+    tasks_json = {\n+        \"master\": {\n+            \"name\": \"Task Master\",\n+            \"version\": \"1.0.0\",\n+            \"description\": f\"Tasks generated from PRD ({simulation_description})\",\n+            \"lastUpdated\": \"2026-01-27T00:00:00Z\",\n+            \"tasks\": [],\n+        }\n+    }\n+\n+    for task_file in original_task_files:\n+        original_info = extract_task_info_func(task_file)\n+\n+        simulated_task = {\n+            \"id\": original_info[\"id\"],\n+            \"title\": original_info[\"title\"],\n+            \"description\": original_info.get(\"purpose\", \"\"),\n+            \"status\": original_info.get(\"status\", \"pending\"),\n+            \"priority\": original_info.get(\"priority\", \"medium\"),\n+            \"dependencies\": [],\n+            \"details\": original_info.get(\"details\", \"\"),\n+            \"subtasks\": [],\n+            \"testStrategy\": original_info.get(\"test_strategy\", \"\"),\n+            \"complexity\": original_info.get(\"complexity\", \"\"),\n+            \"effort\": original_info.get(\"effort\", \"\"),\n+            \"updatedAt\": \"2026-01-27T00:00:00Z\",\n+            \"createdAt\": \"2026-01-27T00:00:00Z\",\n+        }\n+\n+        # Parse dependencies\n+        deps = original_info.get(\"dependencies\", \"\")\n+        if deps and str(deps).lower() not in [\"none\", \"null\", \"\"]:\n+            deps_list = re.split(r\"[,\\s]+| and \", str(deps))\n+            deps_list = [d.strip() for d in deps_list if d.strip()]\n+            simulated_task[\"dependencies\"] = deps_list\n+\n+        # Add extended fields if available\n+        for field in [\n+            \"blocks\",\n+            \"initiative\",\n+            \"scope\",\n+            \"focus\",\n+            \"owner\",\n+            \"prerequisites\",\n+            \"specification_details\",\n+            \"implementation_guide\",\n+            \"configuration_params\",\n+            \"performance_targets\",\n+            \"common_gotchas\",\n+            \"integration_checkpoint\",\n+            \"done_definition\",\n+            \"next_steps\",\n+            \"extended_metadata\",\n+        ]:\n+            if original_info.get(field):\n+                simulated_task[field] = original_info[field]\n+\n+        # Add success criteria\n+        if original_info.get(\"success_criteria\"):\n+            simulated_task[\"success_criteria\"] = original_info[\"success_criteria\"]\n+\n+        # Add subtasks\n+        for subtask in original_info.get(\"subtasks\", []):\n+            simulated_subtask = {\n+                \"id\": subtask.get(\"id\", 1),\n+                \"title\": subtask.get(\"title\", \"\"),\n+                \"description\": \"\",\n+                \"dependencies\": [],\n+                \"details\": \"\",\n+                \"testStrategy\": \"\",\n+                \"status\": subtask.get(\"status\", \"pending\"),\n+                \"parentId\": original_info[\"id\"],\n+                \"effort\": \"\",\n+            }\n+            simulated_task[\"subtasks\"].append(simulated_subtask)\n+\n+        tasks_json[\"master\"][\"tasks\"].append(simulated_task)\n+\n+    # Determine output path\n+    if output_dir:\n+        output_path = Path(output_dir) / \"tasks.json\"\n+    else:\n+        output_path = Path(\"simulated_tasks.json\")\n+\n+    output_path.parent.mkdir(parents=True, exist_ok=True)\n+    with open(output_path, \"w\", encoding=\"utf-8\") as f:\n+        json.dump(tasks_json, f, indent=2)\n+\n+    print(f\"ðŸ“ Simulated tasks written to: {output_path}\")\n+    return str(output_path)\n+\n+\n+def check_task_master_available() -> bool:\n+    \"\"\"Check if task-master is available in PATH.\"\"\"\n+    return shutil.which(\"task-master\") is not None\n",
  "isNewFile": true,
  "reverted": false,
  "timestamp": 1769442199509
}