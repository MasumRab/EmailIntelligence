#+TITLE: EmailIntelligence CLI - Complete Documentation
#+AUTHOR: EmailIntelligence Development Team
#+DATE: 2025-11-22
#+STARTUP: overview
#+OPTIONS: toc:2 num:t

* Overview

The *EmailIntelligence CLI* is an AI-powered git worktree-based conflict resolution tool that implements a structured workflow for intelligent branch merge conflict resolution using constitutional/specification-driven analysis and spec-kit strategies.

** Key Statistics
- *Lines of Code*: 1,418
- *Language*: Python 3.7+
- *Dependencies*: Git 2.5+, argparse, json, subprocess, pathlib, PyYAML (optional)
- *Main File*: =emailintelligence_cli.py=

** Core Features
- Git worktree management for isolated analysis
- Constitutional framework for rule-based compliance
- Spec-kit strategy engine for intelligent resolution
- Interactive workflows with human-in-the-loop
- Multi-level validation system

* Architecture

** Directory Structure

#+BEGIN_EXAMPLE
project-root/
‚îú‚îÄ‚îÄ .git/
‚îÇ   ‚îî‚îÄ‚îÄ worktrees/              # Isolated worktree directories
‚îú‚îÄ‚îÄ resolution-workspace/       # Resolution metadata and progress
‚îú‚îÄ‚îÄ .emailintelligence/
‚îÇ   ‚îú‚îÄ‚îÄ config.yaml             # Tool configuration
‚îÇ   ‚îú‚îÄ‚îÄ constitutions/          # Constitutional rule files
‚îÇ   ‚îî‚îÄ‚îÄ strategies/             # Generated resolution strategies
‚îî‚îÄ‚îÄ emailintelligence_cli.py    # Main CLI tool
#+END_EXAMPLE

** Class Structure

#+BEGIN_SRC python
class EmailIntelligenceCLI:
    """Main CLI class for EmailIntelligence conflict resolution workflow"""
    
    def __init__(self):
        self.repo_root = Path.cwd()
        self.worktrees_dir = self.repo_root / ".git" / "worktrees"
        self.resolution_branches_dir = self.repo_root / "resolution-workspace"
        self.config_file = self.repo_root / ".emailintelligence" / "config.yaml"
        self.constitutions_dir = self.repo_root / ".emailintelligence" / "constitutions"
        self.strategies_dir = self.repo_root / ".emailintelligence" / "strategies"
#+END_SRC

** Component Overview

| Component | Purpose | Key Methods |
|-----------+---------+-------------|
| Setup | Initialize workspace | =setup_resolution()=, =_detect_conflicts()= |
| Analysis | Constitutional compliance | =analyze_constitutional()=, =_assess_constitutional_compliance()= |
| Strategy | Resolution planning | =develop_spec_kit_strategy()=, =_generate_spec_kit_strategy()= |
| Alignment | Execute resolution | =align_content()=, =_execute_phase()= |
| Validation | Quality assurance | =validate_resolution()=, =_perform_validation()= |

* Installation and Setup

** Installation

#+BEGIN_SRC bash
# Make the CLI executable
chmod +x emailintelligence_cli.py

# Optional: Create a symbolic link for easy access
ln -s $(pwd)/emailintelligence_cli.py /usr/local/bin/eai
#+END_SRC

** Configuration File

The tool creates =~/.emailintelligence/config.yaml= with default settings:

#+BEGIN_SRC yaml
constitutional_framework:
  default_constitutions: []
  compliance_threshold: 0.8

worktree_settings:
  cleanup_on_completion: true
  max_worktrees: 10

analysis_settings:
  enable_ai_analysis: false
  detailed_reporting: true
#+END_SRC

** Verify Installation

#+BEGIN_SRC bash
# Check version
eai version

# Test in a git repository (dry-run)
cd /path/to/git/repo
eai setup-resolution --pr 1 --source-branch test --target-branch main --dry-run
#+END_SRC

* Five-Phase Workflow

** Phase 1: Setup Resolution

*** Purpose
Initialize a resolution workspace for a specific PR with isolated git worktrees.

*** Command Syntax

#+BEGIN_SRC bash
eai setup-resolution --pr <number> \
  --source-branch <branch> \
  --target-branch <branch> \
  [--constitution <file>] \
  [--spec <file>] \
  [--dry-run]
#+END_SRC

*** Example

#+BEGIN_SRC bash
# Setup resolution workspace for PR #123
eai setup-resolution \
  --pr 123 \
  --source-branch feature/auth \
  --target-branch main \
  --constitution ./constitutions/security.yaml
#+END_SRC

*** Implementation Details

#+BEGIN_SRC python
def setup_resolution(
    self, pr_number: int, source_branch: str, target_branch: str,
    constitution_files: List[str] = None, spec_files: List[str] = None,
    dry_run: bool = False
) -> Dict[str, Any]:
    """
    Setup resolution workspace for a specific PR
    
    Steps:
    1. Create resolution branch: pr-{number}-resolution
    2. Create worktree-a: source branch (analysis)
    3. Create worktree-b: target branch (target)
    4. Detect conflicts between worktrees
    5. Load constitutions and specifications
    6. Generate resolution metadata
    """
    resolution_branch = f"pr-{pr_number}-resolution"
    worktree_a_path = self.worktrees_dir / f"pr-{pr_number}-branch-a"
    worktree_b_path = self.worktrees_dir / f"pr-{pr_number}-branch-b"
    
    # Create resolution branch
    subprocess.run(
        ["git", "checkout", "-b", resolution_branch],
        cwd=self.repo_root,
        check=True
    )
    
    # Create worktrees
    subprocess.run(
        ["git", "worktree", "add", str(worktree_a_path), source_branch],
        cwd=self.repo_root,
        check=True
    )
    
    subprocess.run(
        ["git", "worktree", "add", str(worktree_b_path), target_branch],
        cwd=self.repo_root,
        check=True
    )
    
    # Detect conflicts
    conflicts = self._detect_conflicts(worktree_a_path, worktree_b_path)
    
    # Create metadata
    resolution_metadata = {
        'pr_number': pr_number,
        'source_branch': source_branch,
        'target_branch': target_branch,
        'resolution_branch': resolution_branch,
        'worktree_a_path': str(worktree_a_path),
        'worktree_b_path': str(worktree_b_path),
        'conflicts': conflicts,
        'status': 'ready_for_analysis'
    }
    
    return resolution_metadata
#+END_SRC

*** Output

The command generates =pr-{number}-metadata.json= containing:
- PR number and branch information
- Worktree paths
- Detected conflicts list
- Constitution/spec files
- Status: =ready_for_analysis=

*** Next Steps

#+BEGIN_SRC bash
# After setup, proceed to constitutional analysis
eai analyze-constitutional --pr 123
#+END_SRC

** Phase 2: Constitutional Analysis

*** Purpose
Analyze conflicts against organizational standards and constitutional rules.

*** Command Syntax

#+BEGIN_SRC bash
eai analyze-constitutional --pr <number> \
  [--constitution <file>] \
  [--interactive]
#+END_SRC

*** Example

#+BEGIN_SRC bash
# Analyze compliance with interactive mode
eai analyze-constitutional \
  --pr 123 \
  --constitution ./constitutions/security.yaml \
  --constitution ./constitutions/api.yaml \
  --interactive
#+END_SRC

*** Constitutional File Format

#+BEGIN_SRC yaml
name: "Authentication Security Constitution"
version: "1.0"
requirements:
  - name: "Secure password hashing"
    type: "MUST"
    validation: "bcrypt minimum cost factor 12"
    
  - name: "JWT token validation"
    type: "MUST"
    validation: "Signature and expiration validation"
    
  - name: "Session timeout"
    type: "SHOULD"
    validation: "Configurable timeout within 30 minutes"
    
  - name: "Rate limiting"
    type: "SHOULD"
    validation: "Per-user and per-IP rate limits"
#+END_SRC

*** Requirement Types

| Type | Priority | Description |
|------+----------+-------------|
| =MUST= | Critical | Must be satisfied (compliance required) |
| =REQUIRED= | Important | Important with some flexibility |
| =SHOULD= | Recommended | Best practices (recommended) |
| =SHOULD_NOT= | Avoid | Practices to avoid |

*** Implementation Details

#+BEGIN_SRC python
def analyze_constitutional(
    self, pr_number: int, constitution_files: List[str] = None,
    interactive: bool = False
) -> Dict[str, Any]:
    """
    Analyze conflicts against loaded constitution
    
    Steps:
    1. Load resolution metadata
    2. Load constitutional rule files
    3. Perform compliance analysis
    4. Generate compliance scores
    5. Identify critical issues
    6. Create analysis report
    """
    # Load metadata
    metadata_file = self.resolution_branches_dir / f"pr-{pr_number}-metadata.json"
    with open(metadata_file) as f:
        metadata = json.load(f)
    
    # Load constitutions
    constitutions = self._load_constitutions(
        constitution_files or metadata.get('constitution_files', [])
    )
    
    # Analyze conflicts
    analysis_results = self._perform_constitutional_analysis(metadata, constitutions)
    
    # Update metadata
    metadata['analysis_results'] = analysis_results
    metadata['status'] = 'constitution_analyzed'
    
    return {
        'pr_number': pr_number,
        'analysis_results': analysis_results,
        'compliance_score': analysis_results.get('overall_compliance', 0.0),
        'critical_issues': analysis_results.get('critical_issues', []),
        'recommendations': analysis_results.get('recommendations', [])
    }
#+END_SRC

*** Compliance Assessment

#+BEGIN_SRC python
def _assess_constitutional_compliance(
    self, conflicts: List[Dict[str, Any]], constitution: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Assess compliance against a single constitution
    
    Returns:
    - compliance_score: 0.0 - 1.0
    - conformant_requirements: List of passing requirements
    - non_conformant_requirements: List of failing requirements
    - partially_conformant_requirements: List of partial compliance
    - critical_issues: List of critical problems
    - recommendations: List of suggested actions
    """
    assessment = {
        'constitution_name': constitution.get('name', 'Unknown'),
        'compliance_score': 0.0,
        'conformant_requirements': [],
        'non_conformant_requirements': [],
        'partially_conformant_requirements': [],
        'critical_issues': [],
        'recommendations': []
    }
    
    # Analyze each requirement
    for req in constitution.get('requirements', []):
        requirement_type = req.get('type', 'MUST')
        # Perform compliance check
        # Add to appropriate list based on status
    
    return assessment
#+END_SRC

*** Output

Analysis report includes:
- Overall compliance score (0.0 - 1.0)
- ‚úÖ Conformant requirements
- ‚ùå Non-conformant requirements
- ‚ö†Ô∏è Partially conformant requirements
- Critical issues list
- Recommendations for resolution

*** Next Steps

#+BEGIN_SRC bash
# After analysis, develop resolution strategy
eai develop-spec-kit-strategy --pr 123
#+END_SRC

** Phase 3: Strategy Development

*** Purpose
Generate intelligent resolution strategy based on conflict analysis.

*** Command Syntax

#+BEGIN_SRC bash
eai develop-spec-kit-strategy --pr <number> \
  [--worktrees] \
  [--alignment-rules <file>] \
  [--interactive] \
  [--review-required]
#+END_SRC

*** Example

#+BEGIN_SRC bash
# Develop strategy with interactive mode
eai develop-spec-kit-strategy \
  --pr 123 \
  --worktrees \
  --alignment-rules ./alignment-rules/custom.yaml \
  --interactive
#+END_SRC

*** Implementation Details

#+BEGIN_SRC python
def develop_spec_kit_strategy(
    self, pr_number: int, worktrees: bool = False,
    alignment_rules: str = None, interactive: bool = False
) -> Dict[str, Any]:
    """
    Develop spec-kit based resolution strategy
    
    Steps:
    1. Verify constitutional analysis is complete
    2. Load alignment rules (if provided)
    3. Generate multi-phase resolution strategy
    4. Plan enhancement preservation
    5. Assess risks and mitigation approaches
    """
    # Load metadata
    metadata_file = self.resolution_branches_dir / f"pr-{pr_number}-metadata.json"
    with open(metadata_file) as f:
        metadata = json.load(f)
    
    # Verify analysis completed
    if metadata.get('status') != 'constitution_analyzed':
        self._warn("Constitutional analysis not yet completed. Running analysis first...")
        self.analyze_constitutional(pr_number)
    
    # Generate strategy
    strategy = self._generate_spec_kit_strategy(metadata, alignment_config)
    
    # Update metadata
    metadata['strategy'] = strategy
    metadata['status'] = 'strategy_developed'
    
    return {
        'pr_number': pr_number,
        'strategy': strategy,
        'phases': len(strategy.get('phases', [])),
        'estimated_resolution_time': strategy.get('estimated_time', 'Unknown'),
        'enhancement_preservation': strategy.get('enhancement_preservation_rate', 0.0)
    }
#+END_SRC

*** Strategy Structure

The generated strategy contains three phases:

**** Phase 1: Content Analysis & Alignment

#+BEGIN_SRC python
phase_1 = {
    'phase': 1,
    'name': 'Content Analysis & Alignment',
    'description': 'Analyze conflicts and determine optimal alignment strategies',
    'steps': [
        {
            'step': 1,
            'file': 'src/auth/login.py',
            'conflicts': 1,
            'alignment_score': '85%',
            'strategy': 'Enhanced merge',
            'estimated_time': '15-30 minutes'
        }
    ],
    'success_criteria': [
        'Analyze all conflicting files',
        'Generate alignment recommendations',
        'Validate constitutional compliance'
    ]
}
#+END_SRC

**** Phase 2: Enhancement Preservation

#+BEGIN_SRC python
phase_2 = {
    'phase': 2,
    'name': 'Enhancement Preservation',
    'description': 'Preserve intended enhancements while resolving conflicts',
    'steps': [
        {
            'step': 1,
            'action': 'Preserve 3 enhancements from source branch',
            'description': 'Feature preservation from feature/auth',
            'preservation_rate': '100%'
        },
        {
            'step': 2,
            'action': 'Integrate 2 improvements from target branch',
            'description': 'Integration of main improvements',
            'preservation_rate': '95%'
        }
    ],
    'success_criteria': [
        '100% functionality preservation from both branches',
        'Zero breaking changes detected',
        'Enhanced system capabilities achieved'
    ]
}
#+END_SRC

**** Phase 3: Risk Mitigation

#+BEGIN_SRC python
phase_3 = {
    'phase': 3,
    'name': 'Risk Mitigation',
    'description': 'Assess and mitigate resolution risks',
    'steps': [
        {
            'step': 1,
            'risk': 'Breaking Changes',
            'assessment': 'None detected',
            'mitigation': 'Comprehensive API compatibility testing'
        },
        {
            'step': 2,
            'risk': 'Performance Impact',
            'assessment': 'Minimal (+3ms average)',
            'mitigation': 'Performance benchmarking and optimization'
        },
        {
            'step': 3,
            'risk': 'Test Coverage',
            'assessment': '15 new test cases required',
            'mitigation': 'Automated test generation and validation'
        }
    ],
    'success_criteria': [
        'Risk assessment completed for all conflict areas',
        'Mitigation strategies implemented',
        'Validation testing passed'
    ]
}
#+END_SRC

*** Output

Strategy report includes:
- Multi-phase execution plan (3 phases)
- Enhancement preservation rate (0.0 - 1.0)
- Risk assessment summary
- Constitutional compliance requirements
- Estimated resolution time

*** Next Steps

#+BEGIN_SRC bash
# After strategy development, execute content alignment
eai align-content --pr 123
#+END_SRC

** Phase 4: Content Alignment

*** Purpose
Execute content alignment based on developed strategy.

*** Command Syntax

#+BEGIN_SRC bash
eai align-content --pr <number> \
  [--strategy <file>] \
  [--dry-run] \
  [--preview-changes] \
  [--interactive] \
  [--checkpoint-each-step]
#+END_SRC

*** Example

#+BEGIN_SRC bash
# Execute alignment with interactive mode and checkpoints
eai align-content \
  --pr 123 \
  --interactive \
  --checkpoint-each-step
#+END_SRC

*** Execution Modes

| Mode | Description | Use Case |
|------+-------------+----------|
| =--dry-run= | Preview without applying changes | Safe testing |
| =--preview-changes= | Show changes before applying | Review before execution |
| =--interactive= | Step-by-step confirmation | Critical changes |
| =--checkpoint-each-step= | Save state after each step | Incremental progress |

*** Implementation Details

#+BEGIN_SRC python
def align_content(
    self, pr_number: int, strategy_file: str = None, dry_run: bool = False,
    preview_changes: bool = False, interactive: bool = False
) -> Dict[str, Any]:
    """
    Execute content alignment based on developed strategy
    
    Steps:
    1. Load strategy from Phase 3
    2. Execute each phase sequentially
    3. Apply constitutional validation
    4. Track alignment scores and progress
    5. Handle interactive confirmations
    """
    # Load metadata and strategy
    metadata_file = self.resolution_branches_dir / f"pr-{pr_number}-metadata.json"
    with open(metadata_file) as f:
        metadata = json.load(f)
    
    strategy = metadata.get('strategy', {})
    
    # Execute each phase
    results = {
        'pr_number': pr_number,
        'phases_executed': [],
        'overall_status': 'in_progress'
    }
    
    for phase in strategy.get('phases', []):
        if dry_run:
            phase_result = self._execute_phase_dry_run(phase, metadata)
        elif interactive:
            phase_result = self._execute_phase_interactive(phase, metadata)
        else:
            phase_result = self._execute_phase(phase, metadata)
        
        results['phases_executed'].append(phase_result)
    
    # Update metadata
    metadata['alignment_results'] = results
    metadata['status'] = 'aligned'
    
    return results
#+END_SRC

*** Phase Execution

#+BEGIN_SRC python
def _execute_phase(self, phase: Dict[str, Any], metadata: Dict[str, Any]):
    """
    Execute a resolution phase
    
    Returns:
    - phase_number: Phase identifier
    - status: success/failed/partial
    - steps_completed: Number of steps completed
    - alignment_score: Phase alignment score
    - issues: List of issues encountered
    """
    phase_result = {
        'phase': phase['phase'],
        'name': phase['name'],
        'status': 'in_progress',
        'steps_completed': 0,
        'total_steps': len(phase.get('steps', [])),
        'issues': []
    }
    
    # Execute each step in the phase
    for step in phase.get('steps', []):
        try:
            # Execute step logic
            phase_result['steps_completed'] += 1
        except Exception as e:
            phase_result['issues'].append(str(e))
    
    # Determine final status
    if phase_result['steps_completed'] == phase_result['total_steps']:
        phase_result['status'] = 'success'
    elif phase_result['steps_completed'] > 0:
        phase_result['status'] = 'partial'
    else:
        phase_result['status'] = 'failed'
    
    return phase_result
#+END_SRC

*** Interactive Mode

#+BEGIN_SRC python
def _execute_phase_interactive(self, phase: Dict[str, Any], metadata: Dict[str, Any]):
    """
    Execute phase with interactive confirmation
    
    Prompts user for confirmation before each step
    """
    print(f"\n{'='*60}")
    print(f"Phase {phase['phase']}: {phase['name']}")
    print(f"{'='*60}")
    print(f"Description: {phase['description']}")
    print(f"Steps: {len(phase.get('steps', []))}")
    
    choice = input("\nProceed with this phase? (y/n): ").lower().strip()
    
    if choice != 'y':
        return {
            'phase': phase['phase'],
            'status': 'skipped',
            'message': 'User skipped phase'
        }
    
    return self._execute_phase(phase, metadata)
#+END_SRC

*** Output

Alignment results include:
- Phase-by-phase execution status
- Steps completed vs. total steps
- Alignment scores and metrics
- Issues encountered
- Overall resolution status

*** Next Steps

#+BEGIN_SRC bash
# After alignment, validate the resolution
eai validate-resolution --pr 123
#+END_SRC

** Phase 5: Validation

*** Purpose
Validate completed content alignment and ensure quality.

*** Command Syntax

#+BEGIN_SRC bash
eai validate-resolution --pr <number> \
  [--comprehensive] \
  [--quick] \
  [--tests <suites>]
#+END_SRC

*** Example

#+BEGIN_SRC bash
# Run comprehensive validation
eai validate-resolution --pr 123 --comprehensive

# Run quick validation
eai validate-resolution --pr 123 --quick

# Run specific test suites
eai validate-resolution --pr 123 --tests "unit,integration,security"
#+END_SRC

*** Validation Levels

| Level | Description | Test Coverage |
|-------+-------------+---------------|
| =--quick= | Basic smoke tests | Essential functionality |
| =--comprehensive= | Full test suite | All tests + compliance |
| =--tests= | Custom test suites | Specified suites only |

*** Implementation Details

#+BEGIN_SRC python
def validate_resolution(
    self, pr_number: int, comprehensive: bool = False, quick: bool = False,
    test_suites: str = None
) -> Dict[str, Any]:
    """
    Validate completed content alignment
    
    Steps:
    1. Load resolution metadata
    2. Determine validation level
    3. Run validation tests
    4. Verify constitutional compliance
    5. Assess overall quality
    6. Generate validation report
    """
    # Load metadata
    metadata_file = self.resolution_branches_dir / f"pr-{pr_number}-metadata.json"
    with open(metadata_file) as f:
        metadata = json.load(f)
    
    # Determine validation level
    if comprehensive:
        level = 'comprehensive'
    elif quick:
        level = 'quick'
    else:
        level = 'standard'
    
    # Perform validation
    validation_results = self._perform_validation(metadata, level, test_suites)
    
    # Update metadata
    metadata['validation_results'] = validation_results
    metadata['status'] = 'validated'
    
    return {
        'pr_number': pr_number,
        'validation_level': level,
        'overall_status': validation_results.get('overall_status', 'unknown'),
        'quality_score': validation_results.get('quality_score', 0.0),
        'tests_passed': validation_results.get('tests_passed', 0),
        'tests_failed': validation_results.get('tests_failed', 0)
    }
#+END_SRC

*** Validation Tests

#+BEGIN_SRC python
def _perform_validation(
    self, metadata: Dict[str, Any], level: str, test_suites: str = None
) -> Dict[str, Any]:
    """
    Perform validation tests
    
    Test Categories:
    - Constitutional compliance
    - Unit tests
    - Integration tests
    - Security tests
    - Performance tests
    """
    results = {
        'validation_level': level,
        'test_results': {},
        'constitutional_compliance': {},
        'quality_score': 0.0,
        'overall_status': 'pending'
    }
    
    # Run constitutional compliance check
    compliance_result = self._validate_constitutional_compliance(metadata)
    results['constitutional_compliance'] = compliance_result
    
    # Run test suites based on level
    if level == 'comprehensive':
        test_categories = ['unit', 'integration', 'security', 'performance']
    elif level == 'quick':
        test_categories = ['unit']
    else:
        test_categories = test_suites.split(',') if test_suites else ['unit']
    
    # Execute tests
    total_passed = 0
    total_failed = 0
    
    for category in test_categories:
        # Mock test execution
        results['test_results'][category] = {
            'passed': 10,
            'failed': 0,
            'skipped': 0
        }
        total_passed += results['test_results'][category]['passed']
        total_failed += results['test_results'][category]['failed']
    
    # Calculate quality score
    total_tests = total_passed + total_failed
    if total_tests > 0:
        test_score = total_passed / total_tests
    else:
        test_score = 0.0
    
    compliance_score = compliance_result.get('compliance_score', 0.0)
    results['quality_score'] = (test_score * 0.6) + (compliance_score * 0.4)
    
    # Determine overall status
    if results['quality_score'] >= 0.95:
        results['overall_status'] = 'excellent'
    elif results['quality_score'] >= 0.80:
        results['overall_status'] = 'good'
    elif results['quality_score'] >= 0.60:
        results['overall_status'] = 'acceptable'
    else:
        results['overall_status'] = 'needs_improvement'
    
    results['tests_passed'] = total_passed
    results['tests_failed'] = total_failed
    
    return results
#+END_SRC

*** Output

Validation report includes:
- Overall validation status (excellent/good/acceptable/needs_improvement)
- Quality score (0.0 - 1.0)
- Tests passed/failed by category
- Constitutional compliance status
- Recommendations for improvement

* Command Reference

** All Available Commands

#+BEGIN_SRC bash
# Setup resolution workspace
eai setup-resolution --pr <number> --source-branch <branch> --target-branch <branch>

# Analyze constitutional compliance
eai analyze-constitutional --pr <number> [--constitution <file>]

# Develop resolution strategy
eai develop-spec-kit-strategy --pr <number> [--worktrees] [--interactive]

# Execute content alignment
eai align-content --pr <number> [--interactive] [--checkpoint-each-step]

# Validate resolution
eai validate-resolution --pr <number> [--comprehensive]

# Show version
eai version
#+END_SRC

** Common Options

| Option | Description | Applicable Commands |
|--------+-------------+---------------------|
| =--pr= | Pull request number | All except version |
| =--dry-run= | Preview without changes | setup-resolution, align-content |
| =--interactive= | Enable interactive mode | analyze-constitutional, develop-spec-kit-strategy, align-content |
| =--constitution= | Constitution file(s) | setup-resolution, analyze-constitutional |
| =--checkpoint-each-step= | Save after each step | align-content |
| =--comprehensive= | Full validation | validate-resolution |

* Complete Workflow Example

** Step-by-Step Resolution

#+BEGIN_SRC bash
# Step 1: Setup resolution environment
eai setup-resolution \
  --pr 142 \
  --source-branch feature/user-auth \
  --target-branch main \
  --constitution ./constitutions/security.yaml

# Output: Creates pr-142-metadata.json with status: ready_for_analysis

# Step 2: Analyze constitutional compliance
eai analyze-constitutional \
  --pr 142 \
  --constitution ./constitutions/security.yaml \
  --constitution ./constitutions/api.yaml \
  --interactive

# Output: Compliance score, critical issues, recommendations
# Status updated to: constitution_analyzed

# Step 3: Develop resolution strategy
eai develop-spec-kit-strategy \
  --pr 142 \
  --worktrees \
  --interactive

# Output: Multi-phase strategy with enhancement preservation
# Status updated to: strategy_developed

# Step 4: Execute content alignment
eai align-content \
  --pr 142 \
  --interactive \
  --checkpoint-each-step

# Output: Phase-by-phase execution results
# Status updated to: aligned

# Step 5: Validate resolution
eai validate-resolution \
  --pr 142 \
  --comprehensive

# Output: Quality score, test results, compliance status
# Status updated to: validated
#+END_SRC

** Metadata Progression

#+BEGIN_SRC json
// After Step 1: setup-resolution
{
  "pr_number": 142,
  "source_branch": "feature/user-auth",
  "target_branch": "main",
  "status": "ready_for_analysis",
  "conflicts": [...]
}

// After Step 2: analyze-constitutional
{
  "status": "constitution_analyzed",
  "analysis_results": {
    "overall_compliance": 0.85,
    "critical_issues": [],
    "recommendations": [...]
  }
}

// After Step 3: develop-spec-kit-strategy
{
  "status": "strategy_developed",
  "strategy": {
    "phases": [...],
    "enhancement_preservation_rate": 0.97
  }
}

// After Step 4: align-content
{
  "status": "aligned",
  "alignment_results": {
    "phases_executed": [...],
    "overall_status": "success"
  }
}

// After Step 5: validate-resolution
{
  "status": "validated",
  "validation_results": {
    "quality_score": 0.92,
    "overall_status": "excellent"
  }
}
#+END_SRC

* Advanced Usage

** Multiple Constitutions

#+BEGIN_SRC bash
# Analyze against multiple constitutional frameworks
eai analyze-constitutional \
  --pr 142 \
  --constitution ./constitutions/security.yaml \
  --constitution ./constitutions/api.yaml \
  --constitution ./constitutions/database.yaml \
  --constitution ./constitutions/performance.yaml
#+END_SRC

** Custom Alignment Rules

#+BEGIN_SRC bash
# Use custom alignment rules for strategy development
eai develop-spec-kit-strategy \
  --pr 142 \
  --alignment-rules ./alignment-rules/custom.yaml \
  --interactive \
  --review-required
#+END_SRC

** Dry-Run Testing

#+BEGIN_SRC bash
# Preview setup without creating worktrees
eai setup-resolution \
  --pr 142 \
  --source-branch feature/auth \
  --target-branch main \
  --dry-run

# Preview alignment without applying changes
eai align-content \
  --pr 142 \
  --dry-run \
  --preview-changes
#+END_SRC

** Specific Test Suites

#+BEGIN_SRC bash
# Run only specific test categories
eai validate-resolution \
  --pr 142 \
  --tests "unit,integration,security"
#+END_SRC

* Troubleshooting

** Common Errors

*** "Not in a git repository"

#+BEGIN_SRC bash
# Verify you're in a git repository
git rev-parse --git-dir

# Check .git directory exists
ls -la .git
#+END_SRC

*** "No resolution workspace found"

#+BEGIN_SRC bash
# Run setup-resolution first
eai setup-resolution --pr 123 --source-branch feature --target-branch main

# Check metadata file exists
ls -la resolution-workspace/pr-123-metadata.json
#+END_SRC

*** "Constitution file not found"

#+BEGIN_SRC bash
# Verify file path
ls -la ./constitutions/security.yaml

# Check file permissions
chmod 644 ./constitutions/security.yaml

# Validate YAML syntax
python3 -c "import yaml; yaml.safe_load(open('./constitutions/security.yaml'))"
#+END_SRC

*** "Worktree creation failed"

#+BEGIN_SRC bash
# Check git version (requires 2.5+)
git --version

# Check disk space
df -h

# Verify write permissions
ls -ld .git/worktrees

# List existing worktrees
git worktree list
#+END_SRC

** Debug Techniques

#+BEGIN_SRC bash
# Use dry-run to preview operations
eai setup-resolution --pr 123 --source-branch feature --target-branch main --dry-run

# Check metadata manually
cat resolution-workspace/pr-123-metadata.json | python3 -m json.tool

# Verify worktrees
git worktree list

# Check git status
git status
#+END_SRC

** Log Files

Resolution operations generate metadata in =resolution-workspace/=:

#+BEGIN_EXAMPLE
resolution-workspace/
‚îú‚îÄ‚îÄ pr-123-metadata.json       # Complete resolution metadata
‚îú‚îÄ‚îÄ pr-123-analysis.md         # Constitutional analysis report
‚îú‚îÄ‚îÄ pr-123-strategy.json       # Resolution strategy
‚îî‚îÄ‚îÄ pr-123-validation.json     # Validation results
#+END_EXAMPLE

* Code Snippets

** Initialization

#+BEGIN_SRC python
#!/usr/bin/env python3
"""
EmailIntelligence CLI - AI-powered git worktree-based conflict resolution tool
"""

import argparse
import hashlib
import json
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List

try:
    import yaml
except ImportError:
    yaml = None
#+END_SRC

** Configuration Loading

#+BEGIN_SRC python
def _load_config(self) -> Dict[str, Any]:
    """Load EmailIntelligence configuration"""
    if not self.config_file.exists():
        default_config = {
            'constitutional_framework': {
                'default_constitutions': [],
                'compliance_threshold': 0.8
            },
            'worktree_settings': {
                'cleanup_on_completion': True,
                'max_worktrees': 10
            },
            'analysis_settings': {
                'enable_ai_analysis': False,
                'detailed_reporting': True
            }
        }
        
        with open(self.config_file, 'w') as f:
            if yaml:
                yaml.dump(default_config, f, default_flow_style=False)
            else:
                json.dump(default_config, f, indent=2)
        
        return default_config
    
    with open(self.config_file) as f:
        if yaml:
            return yaml.safe_load(f)
        else:
            return json.load(f)
#+END_SRC

** Conflict Detection

#+BEGIN_SRC python
def _detect_conflicts(self, worktree_a_path: Path, worktree_b_path: Path) -> List[Dict[str, Any]]:
    """Detect conflicts between worktrees"""
    try:
        # Get list of conflicting files
        result = subprocess.run(
            ["git", "diff", "--name-only"],
            cwd=worktree_a_path,
            check=True,
            capture_output=True,
            text=True
        )
        
        conflicts = []
        for file_path in result.stdout.strip().split('\n'):
            if file_path and not file_path.startswith('.'):
                conflict_info = {
                    'file': file_path,
                    'path_a': str(worktree_a_path / file_path),
                    'path_b': str(worktree_b_path / file_path),
                    'detected_at': datetime.now().isoformat()
                }
                conflicts.append(conflict_info)
        
        self._info(f"üîç Detected {len(conflicts)} potential conflicts")
        return conflicts
        
    except subprocess.CalledProcessError:
        return []
#+END_SRC

** Report Generation

#+BEGIN_SRC python
def _generate_analysis_report(
    self, pr_number: int, metadata: Dict[str, Any], analysis_results: Dict[str, Any]
) -> str:
    """Generate human-readable analysis report"""
    report_lines = [
        f"# Constitutional Analysis Report - PR #{pr_number}",
        "",
        "## Executive Summary",
        f"- **Branch**: {metadata['source_branch']}",
        f"- **Target**: {metadata['target_branch']}",
        f"- **Constitutional Compliance**: {analysis_results['overall_compliance']:.1%}",
        f"- **Critical Issues**: {len(analysis_results.get('critical_issues', []))}",
        f"- **Recommendations**: {len(analysis_results.get('recommendations', []))}",
        "",
        "## Constitutional Assessment",
        ""
    ]
    
    for assessment in analysis_results['constitutional_assessments']:
        report_lines.extend([
            f"### {assessment['constitution_name']} Compliance",
            "",
            f"**Compliance Score**: {assessment['compliance_score']:.1%}",
            ""
        ])
        
        # Add conformant requirements
        if assessment['conformant_requirements']:
            report_lines.append("**‚úÖ Conformant Requirements:**")
            for req in assessment['conformant_requirements']:
                report_lines.append(f"- ‚úÖ **{req['name']}**: {req['type']} (CONFORMANT)")
            report_lines.append("")
        
        # Add non-conformant requirements
        if assessment['non_conformant_requirements']:
            report_lines.append("**‚ùå Non-Conformant Requirements:**")
            for req in assessment['non_conformant_requirements']:
                report_lines.append(f"- ‚ùå **{req['name']}**: {req['type']} (NON_CONFORMANT)")
            report_lines.append("")
    
    return "\n".join(report_lines)
#+END_SRC

** Utility Methods

#+BEGIN_SRC python
def _info(self, message: str):
    """Display info message"""
    print(f"‚ÑπÔ∏è  {message}")

def _success(self, message: str):
    """Display success message"""
    print(f"‚úÖ {message}")

def _warn(self, message: str):
    """Display warning message"""
    print(f"‚ö†Ô∏è  {message}")

def _error(self, message: str):
    """Display error message"""
    print(f"‚ùå {message}", file=sys.stderr)

def _error_exit(self, message: str):
    """Display error message and exit"""
    self._error(message)
    sys.exit(1)
#+END_SRC

* Integration Examples

** CI/CD Integration

#+BEGIN_SRC yaml
# .github/workflows/conflict-resolution.yml
name: EmailIntelligence Conflict Resolution

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  analyze-conflicts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup EmailIntelligence CLI
        run: |
          chmod +x emailintelligence_cli.py
          ln -s $(pwd)/emailintelligence_cli.py /usr/local/bin/eai
      
      - name: Setup Resolution Workspace
        run: |
          eai setup-resolution \
            --pr ${{ github.event.pull_request.number }} \
            --source-branch ${{ github.head_ref }} \
            --target-branch ${{ github.base_ref }} \
            --constitution ./constitutions/security.yaml
      
      - name: Analyze Constitutional Compliance
        run: |
          eai analyze-constitutional \
            --pr ${{ github.event.pull_request.number }} \
            --constitution ./constitutions/security.yaml
      
      - name: Develop Resolution Strategy
        run: |
          eai develop-spec-kit-strategy \
            --pr ${{ github.event.pull_request.number }} \
            --worktrees
      
      - name: Upload Analysis Report
        uses: actions/upload-artifact@v3
        with:
          name: conflict-analysis
          path: resolution-workspace/pr-${{ github.event.pull_request.number }}-*.json
#+END_SRC

** Pre-commit Hook

#+BEGIN_SRC bash
#!/bin/bash
# .git/hooks/pre-commit

# Run quick constitutional analysis on staged changes
if [ -f emailintelligence_cli.py ]; then
    echo "Running EmailIntelligence constitutional check..."
    
    # Create temporary PR for analysis
    TEMP_PR=9999
    CURRENT_BRANCH=$(git branch --show-current)
    
    ./emailintelligence_cli.py setup-resolution \
        --pr $TEMP_PR \
        --source-branch $CURRENT_BRANCH \
        --target-branch main \
        --dry-run
    
    if [ $? -ne 0 ]; then
        echo "‚ùå Constitutional analysis failed"
        exit 1
    fi
    
    echo "‚úÖ Constitutional analysis passed"
fi

exit 0
#+END_SRC

** Python Script Integration

#+BEGIN_SRC python
#!/usr/bin/env python3
"""
Example: Automated conflict resolution workflow
"""

import subprocess
import json
from pathlib import Path

def run_eai_command(command: list) -> dict:
    """Run EmailIntelligence CLI command and return JSON output"""
    result = subprocess.run(
        command,
        capture_output=True,
        text=True,
        check=True
    )
    return json.loads(result.stdout)

def automated_resolution_workflow(pr_number: int, source: str, target: str):
    """Run complete resolution workflow"""
    
    # Step 1: Setup
    print(f"Setting up resolution for PR #{pr_number}...")
    setup_result = run_eai_command([
        'eai', 'setup-resolution',
        '--pr', str(pr_number),
        '--source-branch', source,
        '--target-branch', target,
        '--constitution', './constitutions/security.yaml'
    ])
    print(f"‚úÖ Setup complete: {setup_result['message']}")
    
    # Step 2: Analysis
    print("Analyzing constitutional compliance...")
    analysis_result = run_eai_command([
        'eai', 'analyze-constitutional',
        '--pr', str(pr_number)
    ])
    compliance = analysis_result['compliance_score']
    print(f"‚úÖ Compliance score: {compliance:.1%}")
    
    # Check if compliance is acceptable
    if compliance < 0.8:
        print(f"‚ö†Ô∏è  Compliance below threshold (80%)")
        return False
    
    # Step 3: Strategy
    print("Developing resolution strategy...")
    strategy_result = run_eai_command([
        'eai', 'develop-spec-kit-strategy',
        '--pr', str(pr_number),
        '--worktrees'
    ])
    print(f"‚úÖ Strategy developed: {strategy_result['phases']} phases")
    
    # Step 4: Alignment
    print("Executing content alignment...")
    alignment_result = run_eai_command([
        'eai', 'align-content',
        '--pr', str(pr_number)
    ])
    print(f"‚úÖ Alignment complete")
    
    # Step 5: Validation
    print("Validating resolution...")
    validation_result = run_eai_command([
        'eai', 'validate-resolution',
        '--pr', str(pr_number),
        '--comprehensive'
    ])
    quality = validation_result['quality_score']
    print(f"‚úÖ Quality score: {quality:.1%}")
    
    return quality >= 0.9

if __name__ == '__main__':
    success = automated_resolution_workflow(
        pr_number=142,
        source='feature/user-auth',
        target='main'
    )
    
    if success:
        print("üéâ Resolution workflow completed successfully!")
    else:
        print("‚ùå Resolution workflow failed")
        exit(1)
#+END_SRC

* Best Practices

** Constitutional Design

1. *Keep requirements specific and measurable*
   #+BEGIN_SRC yaml
   # Good
   - name: "Password minimum length"
     type: "MUST"
     validation: "Minimum 12 characters"
   
   # Bad
   - name: "Strong passwords"
     type: "MUST"
     validation: "Use strong passwords"
   #+END_SRC

2. *Use appropriate requirement types*
   - =MUST= for security and critical functionality
   - =SHOULD= for best practices and optimizations
   - =SHOULD_NOT= for anti-patterns

3. *Group related requirements*
   #+BEGIN_SRC yaml
   name: "Authentication Constitution"
   categories:
     - name: "Password Security"
       requirements: [...]
     - name: "Session Management"
       requirements: [...]
   #+END_SRC

** Workflow Optimization

1. *Use dry-run for testing*
   #+BEGIN_SRC bash
   # Always test with dry-run first
   eai setup-resolution --pr 123 --source-branch feature --target-branch main --dry-run
   #+END_SRC

2. *Enable interactive mode for critical changes*
   #+BEGIN_SRC bash
   # Use interactive mode for production branches
   eai align-content --pr 123 --interactive --checkpoint-each-step
   #+END_SRC

3. *Run comprehensive validation before merging*
   #+BEGIN_SRC bash
   # Always validate before merge
   eai validate-resolution --pr 123 --comprehensive
   #+END_SRC

** Metadata Management

1. *Backup metadata before major operations*
   #+BEGIN_SRC bash
   cp resolution-workspace/pr-123-metadata.json \
      resolution-workspace/pr-123-metadata.backup.json
   #+END_SRC

2. *Review metadata after each phase*
   #+BEGIN_SRC bash
   cat resolution-workspace/pr-123-metadata.json | python3 -m json.tool
   #+END_SRC

3. *Clean up completed resolutions*
   #+BEGIN_SRC bash
   # Remove worktrees
   git worktree remove .git/worktrees/pr-123-branch-a
   git worktree remove .git/worktrees/pr-123-branch-b
   
   # Archive metadata
   mv resolution-workspace/pr-123-*.json resolution-workspace/archive/
   #+END_SRC

* Summary

The EmailIntelligence CLI provides a comprehensive, structured approach to git conflict resolution through:

1. *Isolation* - Git worktrees provide clean analysis environments
2. *Standards* - Constitutional frameworks enforce organizational rules
3. *Intelligence* - Spec-kit strategies preserve enhancements
4. *Validation* - Multi-level testing ensures quality
5. *Interactivity* - Human-in-the-loop for critical decisions

** Key Metrics

| Metric | Value |
|--------+-------|
| Lines of Code | 1,418 |
| Workflow Phases | 5 |
| Commands | 6 |
| Constitutional Types | 4 (MUST, REQUIRED, SHOULD, SHOULD_NOT) |
| Validation Levels | 3 (quick, standard, comprehensive) |

** Next Steps

1. Install and configure the CLI
2. Create organizational constitutions
3. Test with dry-run mode
4. Integrate into CI/CD pipeline
5. Train team on workflow

---

*EmailIntelligence CLI v1.0.0* - Transforming git conflicts into structured solutions
