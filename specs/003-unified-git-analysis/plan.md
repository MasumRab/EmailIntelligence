# Implementation Plan: Unified Git Analysis and Verification

**Branch**: `003-unified-git-analysis` | **Date**: 2025-11-11 | **Spec**: `./spec.md`
**Input**: Feature specification from `/specs/003-unified-git-analysis/spec.md`

## Summary

This feature combines the goals of `001-history-analysis` and `002-rebase-analysis` into a single, powerful tool. It will analyze Git history to generate a synthesized "Intent Report" and then use that report to verify the integrity of code after complex operations like merges or rebases.

## Technical Context

**Language/Version**: Python 3.12+
**Primary Dependencies**: GitPython, (potentially a diffing library for detailed content comparison), LLM integration (e.g., via API for narrative synthesis).
**Storage**: N/A (in-memory processing for reports)
**Testing**: pytest
**Target Platform**: Linux server
**Project Type**: Single project (CLI tool)
**Performance Goals**: Generate an Intent Report for a 50-commit branch in under 20 seconds.
**Constraints**: Requires Git to be installed and accessible, including access to the reflog for rebase detection. LLM API access required for narrative synthesis.
**Scale/Scope**: Analysis and verification of git history for a single repository.

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

This plan aims to adhere to all principles outlined in `.specify/memory/constitution.md`.
Any identified potential violations or areas requiring further attention will be
addressed during subsequent phases (Phase 0 Research, Phase 1 Design) or explicitly
justified in the "Complexity Tracking" section.

## Project Structure

### Documentation (this feature)

```text
specs/003-unified-git-analysis/
├── plan.md              # This file
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output
└── tasks.md             # Phase 2 output
```

### Source Code (repository root)

```text
src/
├── models/              # Data models (ActionNarrative, IntentReport, VerificationResult)
├── services/            # Core logic (analysis_service, rebase_detection_service, verification_service)
├── cli/                 # CLI entry points and command handlers
└── lib/                 # Utility functions (git_wrapper, diff_parser, llm_client)
```

**Structure Decision**: A single project structure is appropriate for this CLI tool, promoting modularity and clear separation of concerns.

## Detailed Technical Design

### Narrative Synthesis Logic (FR-001)
The `synthesized_narrative` will be generated by prioritizing code changes, inferring intent from them, and cross-referencing with the commit message. An LLM will be used to generate a human-like summary of both.
- **Code Change Prioritization**: A diff parsing library will extract significant code changes. Heuristics will be applied to identify key functional changes over minor formatting or comment updates.
- **LLM Integration**: A dedicated `llm_client` in `src/lib/` will interface with an LLM API. The prompt to the LLM will include the original commit message and the prioritized code changes (or a summary of them).
- **Consistency Check**: The `is_consistent` flag in `ActionNarrative` will be determined by comparing the LLM-generated narrative with the original commit message and the inferred intent from code changes. Discrepancies will be noted in `discrepancy_notes`.

### Rebase Detection Mechanism (FR-002)
Rebased branches will be detected by looking for "rebase (finish)" messages in the Git reflog.
- The `git_wrapper` in `src/lib/` will provide robust access to the reflog.
- A `rebase_detection_service` in `src/services/` will parse reflog entries and identify branches with the specified pattern.

### Discrepancy Identification (FR-004)
A "discrepancy" during verification is defined as any difference in file content between the Intent Report's expected state and the merged branch's actual state.
- A dedicated `diff_parser` in `src/lib/` will be responsible for comparing file contents at a granular level.
- The `verification_service` in `src/services/` will orchestrate the comparison, iterating through files and their contents as recorded in the `IntentReport` and comparing them against the target merged branch.

### VerificationResult Structure
The `missing_changes` and `unexpected_changes` objects within `VerificationResult` will each contain:
- `commit_hexsha` (string): The SHA-1 hash of the commit associated with the change.
- `file_path` (string): The path to the file where the change occurred.
- `change_type` (string): Indicates whether the change was an "add", "delete", or "modify".

### Handling Intentional Changes (Edge Case)
Intentional changes made during a rebase (e.g., fixing a typo) will be treated as discrepancies unless explicitly marked/ignored by the user.
- The CLI will need a mechanism (e.g., a flag or interactive prompt during `verify`) to allow users to acknowledge and ignore specific discrepancies. This will likely involve storing a configuration or a "whitelist" of approved changes.

## Data Model Refinement

The `data-model.md` will be updated to explicitly define the structure of the `missing_changes` and `unexpected_changes` objects within `VerificationResult` as clarified in the spec.

## Testing Strategy (Detailed)

Adhering to TDD (Constitution Principle II), tests will be written before implementation.
- **Unit Tests (`tests/unit/`)**:
    - `test_git_wrapper.py`: Cover all GitPython interactions, reflog parsing.
    - `test_llm_client.py`: Mock LLM API calls, test prompt construction and response parsing.
    - `test_diff_parser.py`: Test various diff scenarios, code change prioritization heuristics.
    - `test_analysis_service.py`: Test narrative synthesis (mocking LLM and diff parser), `is_consistent` logic.
    - `test_rebase_detection_service.py`: Test reflog pattern matching.
    - `test_verification_service.py`: Test discrepancy detection logic, `VerificationResult` generation.
- **Integration Tests (`tests/integration/`)**:
    - `test_cli.py`: End-to-end tests for `git-verifier analyze`, `detect-rebased`, `verify` commands, ensuring correct CLI argument parsing and output formatting.
    - Test scenarios involving actual Git repositories (mocking LLM API for consistency).
    - Test cases for `SC-001` (95% rebased branch identification) and `SC-002` (99% discrepancy detection).
- **Contract Tests (`tests/contract/`)**:
    - `test_cli_contracts.py`: Validate CLI command structure, arguments, and options against `contracts/cli-contracts.md`.

## Phased Approach

The existing `tasks.md` provides a solid phased approach. This plan provides the necessary detail to execute those tasks effectively.

## Risk Assessment & Mitigation

- **Risk: LLM Cost/Latency**:
    - Mitigation: Implement caching for LLM responses. Allow configuration of LLM model (e.g., cheaper, faster models for initial drafts). Provide an option to disable LLM synthesis for local-only analysis.
- **Risk: GitPython Performance on Large Repos**:
    - Mitigation: Optimize Git operations (e.g., shallow clones, sparse checkouts if applicable). Implement progress indicators (T017). Profile and optimize critical paths.
- **Risk: False Positives/Negatives in Detection/Verification**:
    - Mitigation: Continuously refine heuristics for narrative synthesis and rebase detection. Provide clear `discrepancy_notes` and user-configurable ignore mechanisms. Comprehensive test suite with diverse Git history scenarios.
- **Risk: Complexity of Diff Parsing**:
    - Mitigation: Utilize a well-tested, robust diffing library. Focus on line-level or hunk-level changes initially, then refine to token-level if necessary.

## Performance Considerations

To achieve `SC-004` (Intent Report for 50 commits in under 20 seconds):
- **Git Operations**: Minimize repeated Git commands. Cache GitPython objects.
- **Diff Processing**: Efficient diff parsing, potentially parallelizing diff analysis for multiple commits.
- **LLM Calls**: Batch LLM requests where possible. Optimize LLM prompts for speed. Implement aggressive caching of LLM responses.
- **Profiling**: Use Python's `cProfile` or similar tools to identify and optimize bottlenecks.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
|           |            |                                     |
