import argparse
import json
import os
from pathlib import Path
import sys

from src.lib.git_wrapper import GitWrapper
from src.services.analysis_service import AnalysisService
from src.models.unified_analysis import ActionNarrative, IntentReport, VerificationResult
from datetime import datetime # Import datetime for IntentReport reconstruction

def main():
    parser = argparse.ArgumentParser(prog="git-verifier", description="A unified tool to analyze Git history, generate a synthesized description of intent, and verify the integrity of the code after merges or rebases.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Analyze sub-command
    analyze_parser = subparsers.add_parser("analyze", help="Analyzes commit history to generate a synthesized narrative or a full Intent Report.")
    analyze_parser.add_argument("REVISION_RANGE", nargs="?", help="The commit or range of commits to analyze (e.g., 'HEAD~5..HEAD', a branch name). Defaults to the last 10 commits on the current branch.")
    analyze_parser.add_argument("--report", action="store_true", help="If specified, generates a full IntentReport for the entire branch, not just individual commit narratives.")
    analyze_parser.add_argument("--output-file", type=str, help="Path to save the output (JSON format). If not provided, prints to standard output.")
    analyze_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")

    # Detect-rebased sub-command
    detect_rebased_parser = subparsers.add_parser("detect-rebased", help="Detects local branches that have been rebased and may require verification.")
    detect_rebased_parser.add_argument("--since", type=str, help="Only show branches rebased since a certain date.")
    detect_rebased_parser.add_argument("--json", action="store_true", help="Output the list of branches in JSON format.")
    detect_rebased_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")


    # Verify sub-command
    verify_parser = subparsers.add_parser("verify", help="Verifies a merged branch against a pre-merge Intent Report.")
    verify_parser.add_argument("--report", type=str, required=True, help="Path to the JSON IntentReport file generated by the analyze --report command before the merge.")
    verify_parser.add_argument("--merged-branch", type=str, required=True, help="The name of the branch into which the feature was merged (e.g., 'main').")
    verify_parser.add_argument("--output-file", type=str, help="Path to save the VerificationResult (JSON format). If not provided, prints to standard output.")
    verify_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")

    args = parser.parse_args()

    # Initialize AnalysisService
    try:
        analysis_service = AnalysisService(args.repo_path)
    except Exception as e:
        print(f"Error initializing Git repository at {args.repo_path}: {e}", file=sys.stderr)
        sys.exit(1)

    if args.command == "analyze":
        import asyncio
        asyncio.run(handle_analyze_command(args, analysis_service))
    elif args.command == "detect-rebased":
        import asyncio
        asyncio.run(handle_detect_rebased_command(args, analysis_service))
    elif args.command == "verify":
        import asyncio
        asyncio.run(handle_verify_command(args, analysis_service))
    else:
        parser.print_help()

async def handle_analyze_command(args, analysis_service: AnalysisService):
    if args.report:
        intent_report = await analysis_service.generate_intent_report(
            branch_name=analysis_service.git_wrapper.get_current_branch().name, # Assuming current branch for report
            revision_range=args.REVISION_RANGE
        )
        output_data = intent_report.to_dict()
    else:
        # For individual narratives, we need to iterate commits
        commits = analysis_service.git_wrapper.get_commits(args.REVISION_RANGE)
        narratives = []
        for commit in commits:
            narrative = await analysis_service.generate_action_narrative(commit)
            narratives.append(narrative.to_dict())
        output_data = narratives

    if args.output_file:
        with open(args.output_file, 'w') as f:
            json.dump(output_data, f, indent=4)
    else:
        print(json.dumps(output_data, indent=4))

async def handle_detect_rebased_command(args, analysis_service: AnalysisService):
    rebased_branches = await analysis_service.detect_rebased_branches()
    
    # Filter by --since if provided (placeholder for actual date filtering logic)
    if args.since:
        # For now, just a placeholder. Actual filtering would involve parsing args.since
        # and comparing with reflog entry dates.
        print(f"Filtering rebased branches since {args.since} (not yet implemented)", file=sys.stderr)

    if args.json:
        output_data = rebased_branches
        print(json.dumps(output_data, indent=4))
    else:
        if rebased_branches:
            print("Detected rebased branches:")
            for branch in rebased_branches:
                print(f"- {branch}")
        else:
            print("No rebased branches detected.")

async def handle_verify_command(args, analysis_service: AnalysisService):
    try:
        with open(args.report, 'r') as f:
            report_data = json.load(f)
        
        # Reconstruct IntentReport object
        # The commit_narratives need to be reconstructed into ActionNarrative objects
        commit_narratives = []
        for cn_data in report_data['commit_narratives']:
            # Ensure authored_date is converted back to int if it was stored as such
            cn_data['authored_date'] = int(cn_data['authored_date']) # Assuming it was stored as int timestamp
            commit_narratives.append(ActionNarrative(**cn_data))

        intent_report = IntentReport(
            branch_name=report_data['branch_name'],
            generated_at=datetime.fromisoformat(report_data['generated_at']),
            commit_narratives=commit_narratives
        )
    except FileNotFoundError:
        print(f"Error: Intent Report file not found at {args.report}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON in Intent Report file at {args.report}", file=sys.stderr)
        sys.exit(1)
    except KeyError as e:
        print(f"Error: Missing key in Intent Report data: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error processing Intent Report: {e}", file=sys.stderr)
        sys.exit(1)


    verification_result = await analysis_service.verify_integrity(intent_report, args.merged_branch)
    output_data = verification_result.to_dict()

    if args.output_file:
        with open(args.output_file, 'w') as f:
            json.dump(output_data, f, indent=4)
    else:
        # Human-readable output for verification result
        print(f"Verification Result for branch '{verification_result.branch_name}' (verified at {verification_result.verified_at.isoformat()}):")
        if verification_result.is_fully_consistent:
            print("  Status: FULLY CONSISTENT - No discrepancies found.")
        else:
            print("  Status: DISCREPANCIES DETECTED")
            if verification_result.missing_changes:
                print("  Missing Changes:")
                for change in verification_result.missing_changes:
                    print(f"    - Commit: {change['commit_hexsha'][:7]}, File: {change['file_path']}, Type: {change['change_type']}")
            if verification_result.unexpected_changes:
                print("  Unexpected Changes:")
                for change in verification_result.unexpected_changes:
                    print(f"    - Commit: {change['commit_hexsha'][:7]}, File: {change['file_path']}, Type: {change['change_type']}")


if __name__ == "__main__":
    main()
