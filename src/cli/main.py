import argparse
import json
import os
from pathlib import Path
import sys

from src.lib.git_wrapper import GitWrapper
from src.services.analysis_service import AnalysisService
from src.models.unified_analysis import ActionNarrative, IntentReport, VerificationResult
from datetime import datetime # Import datetime for IntentReport reconstruction
import git # Import git for specific GitPython exceptions
from tqdm import tqdm # Import tqdm for progress bars

def main():
    """
    TODO: Enhance CLI argument parsing and overall structure.

    This `main` function currently sets up the basic command-line interface
    for `git-verifier`. Future enhancements could include:

    1.  **Global Configuration:** Implement a way to read global configurations
        (e.g., from a config file like `.git-verifier.json`) for default
        repository paths, LLM API keys, preferred output formats, etc.
    2.  **More Sub-commands:** Add new sub-commands for other Git analysis
        tasks (e.g., `blame-analysis`, `dependency-graph`, `code-churn`).
    3.  **Plugin System:** Consider a plugin system to allow users to extend
        `git-verifier` with custom analysis modules or output formats.
    4.  **Interactive Mode:** An interactive mode that guides the user through
        analysis steps.
    5.  **Improved Error Reporting:** More detailed stack traces for developers
        while maintaining user-friendly messages for end-users.
    """
    parser = argparse.ArgumentParser(prog="git-verifier", description="A unified tool to analyze Git history, generate a synthesized description of intent, and verify the integrity of the code after merges or rebases.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Analyze sub-command
    analyze_parser = subparsers.add_parser("analyze", help="Analyzes commit history to generate a synthesized narrative or a full Intent Report.")
    analyze_parser.add_argument("REVISION_RANGE", nargs="?", help="The commit or range of commits to analyze (e.g., 'HEAD~5..HEAD', a branch name). Defaults to the last 10 commits on the current branch.")
    analyze_parser.add_argument("--report", action="store_true", help="If specified, generates a full IntentReport for the entire branch, not just individual commit narratives.")
    analyze_parser.add_argument("--output-file", type=str, help="Path to save the output (JSON format). If not provided, prints to standard output.")
    analyze_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")

    # Detect-rebased sub-command
    detect_rebased_parser = subparsers.add_parser("detect-rebased", help="Detects local branches that have been rebased and may require verification.")
    detect_rebased_parser.add_argument("--since", type=str, help="Only show branches rebased since a certain date.")
    detect_rebased_parser.add_argument("--json", action="store_true", help="Output the list of branches in JSON format.")
    detect_rebased_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")


    # Verify sub-command
    verify_parser = subparsers.add_parser("verify", help="Verifies a merged branch against a pre-merge Intent Report.")
    verify_parser.add_argument("--report", type=str, required=True, help="Path to the JSON IntentReport file generated by the analyze --report command before the merge.")
    verify_parser.add_argument("--merged-branch", type=str, required=True, help="The name of the branch into which the feature was merged (e.g., 'main').")
    verify_parser.add_argument("--output-file", type=str, help="Path to save the VerificationResult (JSON format). If not provided, prints to standard output.")
    verify_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")

    args = parser.parse_args()

    # Initialize AnalysisService
    try:
        analysis_service = AnalysisService(args.repo_path)
    except git.InvalidGitRepositoryError:
        print(f"Error: '{args.repo_path}' is not a valid Git repository.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred during Git repository initialization: {e}", file=sys.stderr)
        sys.exit(1)

    if args.command == "analyze":
        import asyncio
        asyncio.run(handle_analyze_command(args, analysis_service))
    elif args.command == "detect-rebased":
        import asyncio
        asyncio.run(handle_detect_rebased_command(args, analysis_service))
    elif args.command == "verify":
        import asyncio
        asyncio.run(handle_verify_command(args, analysis_service))
    else:
        parser.print_help()

async def handle_analyze_command(args, analysis_service: AnalysisService):
    """
    TODO: Enhance the `analyze` command's functionality and output.

    This function handles the `analyze` sub-command. Future enhancements could include:

    1.  **More Output Formats:** Beyond JSON and basic human-readable, add support for
        Markdown, HTML, or interactive reports.
    2.  **Filtering and Sorting:** Allow users to filter narratives by author, date,
        commit message keywords, or sort them by various criteria.
    3.  **LLM Integration Options:** Provide command-line options to specify which
        LLM provider to use, API keys (if not from env), and model parameters.
    4.  **Contextual Analysis:** Allow specifying additional context files or URLs
        to feed into the LLM for richer narrative generation.
    5.  **Progress Bar Refinement:** Pass the `tqdm` progress bar object directly
        to `analysis_service` methods for more accurate and granular updates.
    """
    try:
        if args.report:
            # Pass file=sys.stderr to tqdm to avoid interfering with stdout JSON output
            # or disable if outputting to file
            if args.output_file:
                intent_report = await analysis_service.generate_intent_report(
                    branch_name=analysis_service.git_wrapper.get_current_branch().name,
                    revision_range=args.REVISION_RANGE
                )
            else:
                # tqdm is handled internally by analysis_service.generate_intent_report
                intent_report = await analysis_service.generate_intent_report(
                    branch_name=analysis_service.git_wrapper.get_current_branch().name,
                    revision_range=args.REVISION_RANGE
                )

            output_data = intent_report.to_dict()
            if args.output_file:
                with open(args.output_file, 'w') as f:
                    json.dump(output_data, f, indent=4)
                print(f"Analysis report saved to {args.output_file}")
            else:
                # Human-readable output for IntentReport
                print(f"Intent Report for branch '{intent_report.branch_name}' (Generated at {intent_report.generated_at.isoformat()}):")
                for narrative in intent_report.commit_narratives:
                    print(f"\n--- Commit: {narrative.commit_hexsha[:7]} ---")
                    print(f"Author: {narrative.author_name}")
                    print(f"Date: {datetime.fromtimestamp(narrative.authored_date).isoformat()}")
                    print(f"Message: {narrative.commit_message.strip().splitlines()[0]}")
                    print(f"Narrative: {narrative.synthesized_narrative}")
                    if not narrative.is_consistent:
                        print(f"Consistency: NOT CONSISTENT - {narrative.discrepancy_notes}")
                print("\nAnalysis complete.")
        else:
            # For individual narratives, we need to iterate commits
            commits = list(analysis_service.git_wrapper.get_commits(args.REVISION_RANGE))
            narratives = []
            # tqdm is handled internally by analysis_service.generate_intent_report
            # For individual narratives, we'll just print them as they are generated
            print(f"Analyzing commits in range: {args.REVISION_RANGE or 'default range'}")
            for commit in tqdm(commits, desc="Generating Narratives", file=sys.stderr):
                narrative = await analysis_service.generate_action_narrative(commit)
                narratives.append(narrative.to_dict())
                
                print(f"\n--- Commit: {narrative.commit_hexsha[:7]} ---")
                print(f"Author: {narrative.author_name}")
                print(f"Date: {datetime.fromtimestamp(narrative.authored_date).isoformat()}")
                print(f"Message: {narrative.commit_message.strip().splitlines()[0]}")
                print(f"Narrative: {narrative.synthesized_narrative}")
                if not narrative.is_consistent:
                        print(f"Consistency: NOT CONSISTENT - {narrative.discrepancy_notes}")
            print("\nAnalysis complete.")

    except git.BadName as e:
        print(f"Error: Invalid revision range or branch name '{args.REVISION_RANGE}': {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred during analysis: {e}", file=sys.stderr)
        sys.exit(1)

async def handle_detect_rebased_command(args, analysis_service: AnalysisService):
    """
    TODO: Enhance the `detect-rebased` command's functionality.

    This function handles the `detect-rebased` sub-command. Future enhancements could include:

    1.  **Implement `--since` filter:** Parse the date string and filter reflog
        entries to only show branches rebased after a specific date.
    2.  **More Advanced Rebase Detection:** Beyond just "rebase (finish)", analyze
        reflog patterns for other rebase indicators (e.g., "rebase (start)",
        "rebase (abort)", or specific commit graph patterns).
    3.  **Output Details:** Provide more details about the rebase event (e.g.,
        original base, new base, timestamp of rebase).
    4.  **Integration with `analyze`:** Allow piping the output of `detect-rebased`
        into `analyze` to automatically generate narratives for rebased branches.
    """
    try:
        rebased_branches = await analysis_service.detect_rebased_branches()
        
        # Filter by --since if provided (placeholder for actual date filtering logic)
        if args.since:
            # TODO: Implement actual date filtering logic here.
            # This would involve parsing args.since into a datetime object and
            # comparing it with the timestamp of reflog entries.
            print(f"Filtering rebased branches since {args.since} (not yet implemented)", file=sys.stderr)

        if args.json:
            output_data = rebased_branches
            print(json.dumps(output_data, indent=4))
        else:
            if rebased_branches:
                print("Detected rebased branches:")
                for branch in rebased_branches:
                    print(f"- {branch}")
            else:
                print("No rebased branches detected.")
        print("\nRebase detection complete.")
    except Exception as e:
        print(f"An unexpected error occurred during rebase detection: {e}", file=sys.stderr)
        sys.exit(1)

async def handle_verify_command(args, analysis_service: AnalysisService):
    """
    TODO: Enhance the `verify` command's functionality and reporting.

    This function handles the `verify` sub-command. Future enhancements could include:

    1.  **Detailed Discrepancy Reporting:** Provide more context for each discrepancy,
        such as the exact lines of code that differ, or the specific semantic change
        that was expected but not found (or vice-versa).
    2.  **Handling Intentional Changes:** Implement a mechanism for users to mark
        intentional changes (e.g., via a configuration file or CLI argument) so
        they are not flagged as discrepancies.
    3.  **Different Verification Strategies:** Allow different levels or types of
        verification (e.g., strict file content comparison, semantic comparison, 
        or only checking for presence of key features).
    4.  **Integration with CI/CD:** Design the output and exit codes to be easily
        integrable into CI/CD pipelines for automated integrity checks.
    5.  **Interactive Resolution:** For discrepancies, offer an interactive mode
        to help users understand and potentially resolve them.
    """
    try:
        with open(args.report, 'r') as f:
            report_data = json.load(f)
        
        # Reconstruct IntentReport object
        commit_narratives = []
        for cn_data in report_data['commit_narratives']:
            # Ensure authored_date is converted back to int if it was stored as such
            cn_data['authored_date'] = int(cn_data['authored_date']) # Assuming it was stored as int timestamp
            commit_narratives.append(ActionNarrative(**cn_data))

        intent_report = IntentReport(
            branch_name=report_data['branch_name'],
            generated_at=datetime.fromisoformat(report_data['generated_at']),
            commit_narratives=commit_narratives
        )
    except FileNotFoundError:
        print(f"Error: Intent Report file not found at '{args.report}'. Please ensure the path is correct.", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON format in Intent Report file at '{args.report}'. Please check the file content.", file=sys.stderr)
        sys.exit(1)
    except KeyError as e:
        print(f"Error: Missing expected data in Intent Report file: '{e}'. Please ensure the report is valid.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred while loading the Intent Report: {e}", file=sys.stderr)
        sys.exit(1)


    try:
        # Use tqdm for verification process
        if args.output_file:
            verification_result = await analysis_service.verify_integrity(intent_report, args.merged_branch)
        else:
            # tqdm is handled internally by analysis_service.verify_integrity
            verification_result = await analysis_service.verify_integrity(intent_report, args.merged_branch)

        output_data = verification_result.to_dict()

        if args.output_file:
            with open(args.output_file, 'w') as f:
                json.dump(output_data, f, indent=4)
            print(f"Verification result saved to {args.output_file}")
        else:
            # Human-readable output for verification result
            print(f"Verification Result for branch '{verification_result.branch_name}' (verified at {verification_result.verified_at.isoformat()}):")
            if verification_result.is_fully_consistent:
                print("  Status: FULLY CONSISTENT - No discrepancies found.")
            else:
                print("  Status: DISCREPANCIES DETECTED")
                if verification_result.missing_changes:
                    print("  Missing Changes:")
                    for change in verification_result.missing_changes:
                        print(f"    - Commit: {change['commit_hexsha'][:7]}, File: {change['file_path']}, Type: {change['change_type']}")
                if verification_result.unexpected_changes:
                    print("  Unexpected Changes:")
                    for change in verification_result.unexpected_changes:
                        print(f"    - Commit: {change['commit_hexsha'][:7]}, File: {change['file_path']}, Type: {change['change_type']}")
            print("\nVerification complete.")
    except Exception as e:
        print(f"An unexpected error occurred during verification: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
