import argparse
import json
import os
from pathlib import Path
import sys

from src.lib.git_wrapper import GitWrapper
from src.services.analysis_service import AnalysisService
from src.models.unified_analysis import ActionNarrative, IntentReport, VerificationResult
from datetime import datetime # Import datetime for IntentReport reconstruction
import git # Import git for specific GitPython exceptions
from tqdm import tqdm # Import tqdm for progress bars

def main():
    parser = argparse.ArgumentParser(prog="git-verifier", description="A unified tool to analyze Git history, generate a synthesized description of intent, and verify the integrity of the code after merges or rebases.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Analyze sub-command
    analyze_parser = subparsers.add_parser("analyze", help="Analyzes commit history to generate a synthesized narrative or a full Intent Report.")
    analyze_parser.add_argument("REVISION_RANGE", nargs="?", help="The commit or range of commits to analyze (e.g., 'HEAD~5..HEAD', a branch name). Defaults to the last 10 commits on the current branch.")
    analyze_parser.add_argument("--report", action="store_true", help="If specified, generates a full IntentReport for the entire branch, not just individual commit narratives.")
    analyze_parser.add_argument("--output-file", type=str, help="Path to save the output (JSON format). If not provided, prints to standard output.")
    analyze_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")

    # Detect-rebased sub-command
    detect_rebased_parser = subparsers.add_parser("detect-rebased", help="Detects local branches that have been rebased and may require verification.")
    detect_rebased_parser.add_argument("--since", type=str, help="Only show branches rebased since a certain date.")
    detect_rebased_parser.add_argument("--json", action="store_true", help="Output the list of branches in JSON format.")
    detect_rebased_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")


    # Verify sub-command
    verify_parser = subparsers.add_parser("verify", help="Verifies a merged branch against a pre-merge Intent Report.")
    verify_parser.add_argument("--report", type=str, required=True, help="Path to the JSON IntentReport file generated by the analyze --report command before the merge.")
    verify_parser.add_argument("--merged-branch", type=str, required=True, help="The name of the branch into which the feature was merged (e.g., 'main').")
    verify_parser.add_argument("--output-file", type=str, help="Path to save the VerificationResult (JSON format). If not provided, prints to standard output.")
    verify_parser.add_argument("--repo-path", type=str, default=os.getcwd(), help="Path to the Git repository. Defaults to the current working directory.")

    args = parser.parse_args()

    # Initialize AnalysisService
    try:
        analysis_service = AnalysisService(args.repo_path)
    except git.InvalidGitRepositoryError:
        print(f"Error: '{args.repo_path}' is not a valid Git repository.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred during Git repository initialization: {e}", file=sys.stderr)
        sys.exit(1)

    if args.command == "analyze":
        import asyncio
        asyncio.run(handle_analyze_command(args, analysis_service))
    elif args.command == "detect-rebased":
        import asyncio
        asyncio.run(handle_detect_rebased_command(args, analysis_service))
    elif args.command == "verify":
        import asyncio
        asyncio.run(handle_verify_command(args, analysis_service))
    else:
        parser.print_help()

async def handle_analyze_command(args, analysis_service: AnalysisService):
    try:
        if args.report:
            # Pass file=sys.stderr to tqdm to avoid interfering with stdout JSON output
            # or disable if outputting to file
            if args.output_file:
                intent_report = await analysis_service.generate_intent_report(
                    branch_name=analysis_service.git_wrapper.get_current_branch().name,
                    revision_range=args.REVISION_RANGE
                )
            else:
                # tqdm is handled internally by analysis_service.generate_intent_report
                intent_report = await analysis_service.generate_intent_report(
                    branch_name=analysis_service.git_wrapper.get_current_branch().name,
                    revision_range=args.REVISION_RANGE
                )

            output_data = intent_report.to_dict()
            if args.output_file:
                with open(args.output_file, 'w') as f:
                    json.dump(output_data, f, indent=4)
                print(f"Analysis report saved to {args.output_file}")
            else:
                # Human-readable output for IntentReport
                print(f"Intent Report for branch '{intent_report.branch_name}' (Generated at {intent_report.generated_at.isoformat()}):")
                for narrative in intent_report.commit_narratives:
                    print(f"\n--- Commit: {narrative.commit_hexsha[:7]} ---")
                    print(f"Author: {narrative.author_name}")
                    print(f"Date: {datetime.fromtimestamp(narrative.authored_date).isoformat()}")
                    print(f"Message: {narrative.commit_message.strip().splitlines()[0]}")
                    print(f"Narrative: {narrative.synthesized_narrative}")
                    if not narrative.is_consistent:
                        print(f"Consistency: NOT CONSISTENT - {narrative.discrepancy_notes}")
                print("\nAnalysis complete.")
        else:
            # For individual narratives, we need to iterate commits
            commits = list(analysis_service.git_wrapper.get_commits(args.REVISION_RANGE))
            narratives = []
            # tqdm is handled internally by analysis_service.generate_intent_report
            # For individual narratives, we'll just print them as they are generated
            print(f"Analyzing commits in range: {args.REVISION_RANGE or 'default range'}")
            for commit in tqdm(commits, desc="Generating Narratives", file=sys.stderr):
                narrative = await analysis_service.generate_action_narrative(commit)
                narratives.append(narrative.to_dict())
                
                print(f"\n--- Commit: {narrative.commit_hexsha[:7]} ---")
                print(f"Author: {narrative.author_name}")
                print(f"Date: {datetime.fromtimestamp(narrative.authored_date).isoformat()}")
                print(f"Message: {narrative.commit_message.strip().splitlines()[0]}")
                print(f"Narrative: {narrative.synthesized_narrative}")
                if not narrative.is_consistent:
                    print(f"Consistency: NOT CONSISTENT - {narrative.discrepancy_notes}")
            print("\nAnalysis complete.")

    except git.BadName as e:
        print(f"Error: Invalid revision range or branch name '{args.REVISION_RANGE}': {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred during analysis: {e}", file=sys.stderr)
        sys.exit(1)

async def handle_detect_rebased_command(args, analysis_service: AnalysisService):
    try:
        rebased_branches = await analysis_service.detect_rebased_branches()
        
        # Filter by --since if provided (placeholder for actual date filtering logic)
        if args.since:
            # For now, just a placeholder. Actual filtering would involve parsing args.since
            # and comparing with reflog entry dates.
            print(f"Filtering rebased branches since {args.since} (not yet implemented)", file=sys.stderr)

        if args.json:
            output_data = rebased_branches
            print(json.dumps(output_data, indent=4))
        else:
            if rebased_branches:
                print("Detected rebased branches:")
                for branch in rebased_branches:
                    print(f"- {branch}")
            else:
                print("No rebased branches detected.")
        print("\nRebase detection complete.")
    except Exception as e:
        print(f"An unexpected error occurred during rebase detection: {e}", file=sys.stderr)
        sys.exit(1)

async def handle_verify_command(args, analysis_service: AnalysisService):
    try:
        with open(args.report, 'r') as f:
            report_data = json.load(f)
        
        # Reconstruct IntentReport object
        commit_narratives = []
        for cn_data in report_data['commit_narratives']:
            # Ensure authored_date is converted back to int if it was stored as such
            cn_data['authored_date'] = int(cn_data['authored_date']) # Assuming it was stored as int timestamp
            commit_narratives.append(ActionNarrative(**cn_data))

        intent_report = IntentReport(
            branch_name=report_data['branch_name'],
            generated_at=datetime.fromisoformat(report_data['generated_at']),
            commit_narratives=commit_narratives
        )
    except FileNotFoundError:
        print(f"Error: Intent Report file not found at '{args.report}'. Please ensure the path is correct.", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON format in Intent Report file at '{args.report}'. Please check the file content.", file=sys.stderr)
        sys.exit(1)
    except KeyError as e:
        print(f"Error: Missing expected data in Intent Report file: '{e}'. Please ensure the report is valid.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred while loading the Intent Report: {e}", file=sys.stderr)
        sys.exit(1)


    try:
        # Use tqdm for verification process
        if args.output_file:
            verification_result = await analysis_service.verify_integrity(intent_report, args.merged_branch)
        else:
            # tqdm is handled internally by analysis_service.verify_integrity
            verification_result = await analysis_service.verify_integrity(intent_report, args.merged_branch)

        output_data = verification_result.to_dict()

        if args.output_file:
            with open(args.output_file, 'w') as f:
                json.dump(output_data, f, indent=4)
            print(f"Verification result saved to {args.output_file}")
        else:
            # Human-readable output for verification result
            print(f"Verification Result for branch '{verification_result.branch_name}' (verified at {verification_result.verified_at.isoformat()}):")
            if verification_result.is_fully_consistent:
                print("  Status: FULLY CONSISTENT - No discrepancies found.")
            else:
                print("  Status: DISCREPANCIES DETECTED")
                if verification_result.missing_changes:
                    print("  Missing Changes:")
                    for change in verification_result.missing_changes:
                        print(f"    - Commit: {change['commit_hexsha'][:7]}, File: {change['file_path']}, Type: {change['change_type']}")
                if verification_result.unexpected_changes:
                    print("  Unexpected Changes:")
                    for change in verification_result.unexpected_changes:
                        print(f"    - Commit: {change['commit_hexsha'][:7]}, File: {change['file_path']}, Type: {change['change_type']}")
            print("\nVerification complete.")
    except Exception as e:
        print(f"An unexpected error occurred during verification: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()