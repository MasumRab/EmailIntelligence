    def _sort_emails_by_date(self, emails: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Helper to sort emails by date (newest first)."""
        try:
            return sorted(
                emails,
                key=lambda e: e.get(FIELD_TIME, e.get(FIELD_CREATED_AT, "")),
                reverse=True,
            )
        except TypeError:
            logger.warning(
                f"Sorting emails by {FIELD_TIME} failed due to incomparable types. Using '{FIELD_CREATED_AT}'."
            )
            return sorted(
                emails, key=lambda e: e.get(FIELD_CREATED_AT, ""), reverse=True
            )

    async def _sort_and_paginate_emails(
        self,
        emails: List[Dict[str, Any]],
        limit: int = 50,
        offset: int = 0,
    ) -> List[Dict[str, Any]]:
        """Sorts and paginates a list of emails."""
        sorted_emails = self._sort_emails_by_date(emails)
        paginated_emails = sorted_emails[offset : offset + limit]
        result_emails = [self._add_category_details(email) for email in paginated_emails]
        return result_emails

    async def search_emails_with_limit(
        self, search_term: str, limit: int = 50, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Search emails with limit and offset parameter using Sort-First Early-Exit strategy.
        Searches subject/sender in-memory, and content on-disk.
        """
        if not search_term:
            return await self.get_emails(limit=limit, offset=offset)

        # Check cache
        cache_key = f"search_{search_term}_{limit}_{offset}"
        cached_result = self.caching_manager.get_query_result(cache_key)
        if cached_result is not None:
            return cached_result

        search_term_lower = search_term.lower()

        # Sort emails first (Sort-First strategy) using shared helper
        sorted_emails = self._sort_emails_by_date(self.emails_data)

        result_emails = []
        skipped_count = 0

        # Generator for light filtering
        for email_light in sorted_emails:
            # Stop if we have enough
            if len(result_emails) >= limit:
                break

            # Light check (in-memory)
            found_in_light = (
                search_term_lower in email_light.get(FIELD_SUBJECT, "").lower()
                or search_term_lower in email_light.get(FIELD_SENDER, "").lower()
                or search_term_lower in email_light.get(FIELD_SENDER_EMAIL, "").lower()
            )

            is_match = False
            if found_in_light:
                is_match = True
            else:
                # Heavy check (on-disk)
                email_id = email_light.get(FIELD_ID)
                content_path = self._get_email_content_path(email_id)
                if os.path.exists(content_path):
                    try:
                        # Use asyncio.to_thread for I/O to check content without blocking
                        def check_content():
                            with gzip.open(content_path, "rt", encoding="utf-8") as f:
                                heavy_data = json.load(f)
                                content = heavy_data.get(FIELD_CONTENT, "")
                                return isinstance(content, str) and search_term_lower in content.lower()

                        if await asyncio.to_thread(check_content):
                            is_match = True
                    except (IOError, json.JSONDecodeError) as e:
                        # Log error but don't crash search.
                        # This matches review feedback about error handling visibility (keep as error or warning).
                        logger.error(f"Could not search content for email {email_id}: {e}")

            if is_match:
                if skipped_count < offset:
                    skipped_count += 1
                    continue
                result_emails.append(self._add_category_details(email_light))

        # Cache result
        self.caching_manager.put_query_result(cache_key, result_emails)
        return result_emails
